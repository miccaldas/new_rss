<p>On January 13th 2022, Firefox became unusable for close to two hours for users worldwide.<br>This incident interrupted many people’s workflow.<br>This post highlights the complex series of events and circumstances that, together, triggered a bug deep in the networking code of Firefox.Firefox has a number of servers and related infrastructure that handle several internal services.<br>These include updates, telemetry, certificate management, crash reporting and other similar functionality.<br>This infrastructure is hosted by different cloud service providers that use load balancers to distribute the load evenly across servers.<br>For those services hosted on Google Cloud Platform (GCP) these load balancers have settings related to the HTTP protocol they should advertise and one of these settings is HTTP/3 support with three states: “Enabled”, “Disabled” or “Automatic (default)”.<br>Our load balancers were set to the “Automatic (default)” setting and on January 13, 2022 at 07:28 UTC, GCP deployed an unannounced change to make HTTP/3 the default.<br>As Firefox uses HTTP/3 when supported, from that point forward, some connections that Firefox makes to the services infrastructure would use HTTP/3 instead of the previously used HTTP/2 protocol.Shortly after, we noticed a spike in crashes being reported through our crash reporter and also received several reports from inside and outside of Mozilla describing a hang of the browser.As part of the incident response process, we quickly discovered that the client was hanging inside a network request to one of the Firefox internal services.<br>However, at this point we neither had an explanation for why this would trigger just now, nor what the scope of the problem was.<br>We continued to look for the “trigger” — some change that must have occurred to start the problem.<br>We found that we had not shipped updates or configuration changes that could have caused this problem.<br>At the same time, we were keeping in mind that HTTP/3 had been enabled since Firefox 88 and was actively used by some popular websites.Although we couldn’t see it, we suspected that there had been some kind of “invisible” change rolled out by one of our cloud providers that somehow modified load balancer behavior.<br>On closer inspection, none of our settings were changed.<br>We then discovered through logs that for some reason, the load balancers for our Telemetry service were serving HTTP/3 connections while they hadn’t done that before.<br>We disabled HTTP/3 explicitly on GCP at 09:12 UTC.<br>This unblocked our users, but we were not yet certain about the root cause and without knowing that, it was impossible for us to tell if this would affect additional HTTP/3 connections.It quickly became clear to us that there must be some combination of special circumstances for the hang to occur.<br>We performed a number of tests with various tools and remote services and were not able to reproduce the problem, not even with a regular connection to the Telemetry staging server (a server only used for testing deployments, which we had left in its original configuration for testing purposes).<br>With Firefox itself, however, we were able to reproduce the issue with the staging server.After further debugging, we found the “special ingredient” required for this bug to happen.<br>All HTTP/3 connections go through Necko, our networking stack.<br>However, Rust components that need direct network access are not using Necko directly, but are calling into it through an intermediate library called .In order to understand why this mattered, we first need to understand some things about the internals of Necko, in particular about HTTP/3 upload requests.<br>For such requests, the higher-level Necko APIs check if the  header is present and if it isn’t, it will automatically be added.<br>The lower-level HTTP/3 code later relies on this header to determine the request size.<br>This works fine for web content and other requests in our code.When requests pass through  first, however,  will lower-case each header and pass it on to Necko.<br>And here is the problem: the API checks in Necko are case- while the lower-level HTTP/3 code is case-.<br>So if any code was to add a  header and pass the request through , it would pass the Necko API checks but the HTTP/3 code would not find the header.It just so happens that Telemetry is currently the only Rust-based component in Firefox Desktop that uses the network stack and adds a  header.<br>This is why users who disabled Telemetry would see this problem resolved even though the problem is not related to Telemetry functionality itself and could have been triggered otherwise.With the load balancer change in place, and a special code path in a new Rust service now active, the necessary final ingredient to trigger the problem for users was deep in Necko HTTP/3 code.When handling a request, the code  and failed to find the header as it had been lower-cased by .<br>Without the header, the request was determined by the Necko code to be complete, leaving the real request body unsent.<br>However, this code would only terminate when there was no additional content to send.<br>This .<br>Because all network requests go through one , this loop blocked any further network communication and made Firefox unresponsive, unable to load web content.As so often is the case, the issue was a lot more complex than it appeared at first glance and there were many contributing factors working together.<br>Some of the key factors we have identified include:GCP’s deployment of HTTP/3 as default was unannounced.<br>We are actively working with them to improve the situation.<br>We realize that an announcement (as is usually sent) might not have entirely mitigated the risk of an incident, but it would likely have triggered more controlled experiments (e.g.<br>in a staging environment) and deployment.Our setting of “Automatic (default)” on the load balancers instead of a more explicit choice allowed the deployment to take place automatically.<br>We are reviewing all service configurations to avoid similar mistakes in the future.The particular combination of HTTP/3 and  on Firefox Desktop was not covered in our continuous integration system.<br>While we cannot test every possible combination of configurations and components, the choice of HTTP version is a fairly major change that should have been tested, as well as the use of an additional networking layer like .<br>Current HTTP/3 tests cover the low-level protocol behavior and the Necko layer as it is used by web content.<br>We should run more system tests with different HTTP versions and doing so could have revealed this problem.We are also investigating action points both to make the browser more resilient towards such problems and to make incident response even faster.<br>Learning as much as possible from this incident will help us improve the quality of our products.<br>We’re grateful to all the users who have sent crash reports, worked with us in Bugzilla or helped others to work around the problem.Christian is a Firefox Tech Lead and Senior Staff Security Engineer at Mozilla.Sign up for the Mozilla Developer Newsletter:If you haven’t previously confirmed a subscription to a Mozilla-related newsletter you may have to do so.<br>Please check your inbox or your spam filter for an email from us.
  Excellent explanation of the issue.<br>Very interesting read.<br>Why isn’t one of the lessons learned to treat headers in a case-insensitive way? That’s how they are supposed to be treated according to every HTTP standard, after all, and it would have avoided the issue in this case.<br>Headers are already treated in this way and the one place where the check was case-sensitive was simply a bug that could only be triggered by internal code, so it went undetected.<br>
          Except where otherwise noted, content on this site is licensed
          under the
          
          or any later version.
        </p>
