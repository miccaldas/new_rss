[
{"title": "Introduction", "links": "/_login", "content": "This is entirely the fault of a friend complaining about trying to move software between different versions of RHEL. I don\u2019t know why I\u2019m doing this, but it seemed like a good idea at the time. Why is this page named what it is? No idea. This was done in Jan 2022.", "images": []},
{"title": "Problem", "links": "/_logout", "content": "People have Opinions about DLL\u2019s these days. (I know Linux calls them shared objects, but that\u2019s a dumb name, so I\u2019ll call them DLL\u2019s.) DLL\u2019s add a level of complexity to writing and using software, and newer languages like Rust and Go have eschewed them, while Alpine Linux and maybe some other distributions also just don\u2019t bother using them. On the other hand, they exist for a reason, ie sharing compiled code with a common ABI between multiple programs. This has produced a fair amount of discourse the last few years asking interesting questions: Are they necessary? Are they useful? Are they worth the trouble? Can we reinvent the linking process to make the whole system better? These conversations tend to have a lot of Opinion to them and not much actual data, so let\u2019s start collecting data.", "images": []},
{"title": "Count uses per DLL", "links": "/_login", "content": "What data do we collect? Well, I am going to be looking at my everyday Linux system, an x86_64 desktop running Debian Bookworm. This is a quick-and-dirty survey: I want to do this analysis in like 90 minutes or so, and I will never do much with the results beyond going \u201chmm, that\u2019s neat\u201d. For the data I want it would probably be best to make a small sqlite database, import everything under the sun into it, and then have a set of SQL queries to do the actual analysis, but I don\u2019t particularly like SQL and have to re-learn it every time I use it, so that would take Time. Next best bet would be to write a pipeline in Python or Julia or something and use either CSV or JSON files as intermediate products, but I\u2019m bored of Python and don\u2019t feel like learning Julia right now, so I\u2019m not going to do that either. Hence if I can\u2019t do something with shell scripting, I\u2019m not going to do it.", "images": []},
{"title": "Count DLL\u2019s per file", "links": "/_logout", "content": "Also note I have a bit of background in data science, but was never terribly good at it, so I\u2019m just doing this for fun. Hence I will write this process down tutorial-style in the hopes of it being interesting to others, or in case someone dares try to reproduce the process. If you\u2019re not interested in the process, just skip to the bottom of each section for the conclusions. The overall question we are trying to answer here is: \u201cHow useful are DLL\u2019s?\u201d This data will not answer that question, but may let us start measuring some pieces of it.", "images": []},
{"title": "Graphs!", "links": "/Dllicious", "content": "Easy things first. How often is each DLL in the system actually used?", "images": []},
{"title": "Analysis", "links": "/_edit/Dllicious", "content": "First, we find all executable files:", "images": []},
{"title": "Conclusions", "links": "/_history/Dllicious", "content": "(make sure you don\u2019t have any remote filesystems mounted unless you want to wait, or give the ", "images": []},
{"title": "Future work", "links": "/_discuss/Dllicious", "content": " option to ", "images": []},
{"title": "missing", "links": "/Dllicious", "content": ", though that won\u2019t do what you want if you have say ", "images": []},
{"title": "missing", "links": "#introduction", "content": " and ", "images": []},
{"title": "missing", "links": "#problem", "content": " on separate drives.", "images": []},
{"title": "missing", "links": "#count-uses-per-dll", "content": "How many executable files do we have?", "images": []},
{"title": "missing", "links": "#count-dlls-per-file", "content": "Ok. Do we have any duplicates?", "images": []},
{"title": "missing", "links": "#graphs", "content": "We don\u2019t, good.", "images": []},
{"title": "missing", "links": "#analysis", "content": "Run ", "images": []},
{"title": "missing", "links": "#disk-space", "content": " on all files in parallel and save the results:", "images": []},
{"title": "missing", "links": "#memory", "content": "If the file is not an ELF executable then it will output ", "images": []},
{"title": "missing", "links": "#conclusions", "content": " to stderr, not stdout, so we\u2019re gucci, that won\u2019t go into our data file. If the file is an ELF executable that uses no DLL\u2019s, it will output ", "images": []},
{"title": "missing", "links": "#future-work", "content": " to stdout, so we can keep track of those too if we want.", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Zipf%27s_law", "content": "The ", "images": []},
{"title": "missing", "links": "/_category/computer", "content": " file looks like this:", "images": []},
{"title": "missing", "links": "/_category/badideas", "content": "Snip off everything that doesn\u2019t start with a space:", "images": []},
{"title": "missing", "links": "http://github.com/jgm/gitit/tree/master/", "content": "Now it looks like this:", "images": []},
{"title": "missing", "links": "/", "content": "We only care about the DLL symbol name, so chop off everything after the first non-leading space:", "images": []},
{"title": "missing", "links": "/", "content": "Ok, how many lines are in there?", "images": []},
{"title": "missing", "links": "/_index", "content": "So all the DLL\u2019s on the system put together are used 208,000 times. This is a sort of weird measurement, it\u2019s \u201cthe sum of the count of the DLL\u2019s used by each executable\u201d. Let\u2019s turn it into something more handy, a frequency count of how many times each DLL is used.", "images": []},
{"title": "missing", "links": "/_categories", "content": "So there are 1654 separate DLL\u2019s used on this system. Eyeballing the ", "images": []},
{"title": "missing", "links": "/_random", "content": " file, the top of it looks like this:", "images": []},
{"title": "missing", "links": "/_activity", "content": "And the bottom of it looks like this:", "images": []},
{"title": "missing", "links": "/_upload", "content": "So we now know how many times each DLL is used on the system. There are some artifacts in there, I\u2019m not sure happened to give us a DLL named ", "images": []},
{"title": "missing", "links": "/Help", "content": " or ", "images": []},
{"title": "missing", "links": "/_showraw/Dllicious", "content": "; obviously something in our text processing step mangled some names. Taking 30 seconds to eyeball the file doesn\u2019t turn up too many other implausible-looking things, so I don\u2019t care. This is our quick-and-dirty pass after all.", "images": []},
{"title": "missing", "links": "/Dllicious?printable", "content": "Another anomaly worth keeping track of is statically linked executables. Our lame string-processing approach means that the ", "images": []},
{"title": "missing", "links": "/_delete/Dllicious", "content": " output of ", "images": []},
{"title": "missing", "links": "missing", "content": " gets conveniently preserved and tallied up like any other DLL:", "images": []},
{"title": "missing", "links": "missing", "content": "I didn\u2019t expect many statically linked executables, but I did expect more than that.", "images": []},
{"title": "missing", "links": "missing", "content": "Anyway, not terribly surprisingly, it appears that there\u2019s a handful of DLL\u2019s that are used by almost everything, a pretty steep decline, and then it tapers off into a long tail. I\u2019d expect it to be something like an exponential dropoff, because ", "images": []},
{"title": "missing", "links": "missing", "content": ". We might dig a bit more into this data set later, but I tend to prefer to do a breadth-first search on these sorts of problems. Touch a lot of little things lightly, then go back and decide what to dig further into.", "images": []},
{"title": "missing", "links": "missing", "content": "Ok, so we now know how many times each DLL is used. Let\u2019s do the inverse as well, and find out how many DLL\u2019s each executable uses. To do this we have to go allll the way back to ", "images": []},
{"title": "missing", "links": "missing", "content": ". This is why, whenever you do data science, you either script the whole process at once, or you keep every intermediate data product and write down exactly how it\u2019s produced like I\u2019m doing right now.", "images": []},
{"title": "missing", "links": "missing", "content": "We can\u2019t feed a shell pipeline into xargs, so I can\u2019t just do ", "images": []},
{"title": "missing", "links": "missing", "content": " or something. Easy way around is to make a shell script that outputs the data we are interested in. So:", "images": []},
{"title": "missing", "links": "missing", "content": "Then we just run", "images": []},
{"title": "missing", "links": "missing", "content": "and it bombs out early for some reason. A little digging through the output turns up the error message ", "images": []},
{"title": "missing", "links": "missing", "content": ", so unsurprisingly a single-quote in a file name somewhere is totally hosing our shell script. This is where a sane person would drop bash like the live grenade it is; a few minutes of trying to make the ", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": " option cooperate results in it stubbornly saying ", "images": []},
{"title": "missing", "links": "missing", "content": ", which is just so helpful. Eyeballing the data file however, we can find that most instances of single or double quotes are music or data files that are accidentally marked executable, so we can just get rid of them:", "images": []},
{"title": "missing", "links": "missing", "content": "Sorry ", "images": []},
{"title": "missing", "links": "missing", "content": ", we will not find out how many DLL\u2019s you need linked into your program space when started.", "images": []},
{"title": "missing", "links": "missing", "content": "Ok but my bash script is now breaking on files that have spaces in their names, which is quite a lot of them. OF COURSE. Most of those files are probably unimportant, but there\u2019s enough of them in odd places that I don\u2019t want to filter them out or spot check them or such. FINE, we\u2019ll do it the STUPID and SLOW way, since I\u2019m sick of Python in my life and I don\u2019t feel like spending the afternoon learning Julia and ", "images": []},
{"title": "missing", "links": "missing", "content": " might or might not be able to fix the problem but this works dammit:", "images": []},
{"title": "missing", "links": "missing", "content": "Great, now the file looks like this:", "images": []},
{"title": "missing", "links": "missing", "content": "The first number is the number of dll\u2019s, and 0 means \u201cnot an ELF executable\u201d. So we snip out everything ending with ", "images": []},
{"title": "missing", "links": "missing", "content": " and remove empty newlines:", "images": []},
{"title": "missing", "links": "missing", "content": "Great, now we have this:", "images": []},
{"title": "missing", "links": "missing", "content": "Let\u2019s use awk to just turn it into ", "images": []},
{"title": "missing", "links": "missing", "content": " so we can sort it sanely:", "images": []},
{"title": "missing", "links": "missing", "content": "FAK that ALSO fucks up on filenames with spaces in them. This is why you shouldn\u2019t use shell for anything fancy, folks. Okay, let\u2019s change our ", "images": []},
{"title": "missing", "links": "missing", "content": " script to do the filtering itself, and output the count first because we know that will just be a number with no heckin\u2019 spaces or quotes or any other BS in it:", "images": []},
{"title": "missing", "links": "missing", "content": "GREAT now it works and we\u2019ve also eliminated an extra step. Fucking hell. Let\u2019s run our slow and terrible brute force loop again:", "images": []},
{"title": "missing", "links": "missing", "content": "Well that seems to be working, but pretty slowly. While it\u2019s running I might as well try to make ", "images": []},
{"title": "missing", "links": "missing", "content": " handle the stupid thing to see if I can make it use all my cores. If I can figure out the correct ", "images": []},
{"title": "missing", "links": "missing", "content": " invocation before the for loop finishes, it wins.", "images": []},
{"title": "missing", "links": "missing", "content": "Hey, that was easier than expected. However, this is still the part where you go get a cup of tea, maybe a sandwich, and possibly do some push-ups. The first ", "images": []},
{"title": "missing", "links": "missing", "content": " run processed a similar amount of data in similar ways, but the pipeline and such in ", "images": []},
{"title": "missing", "links": "missing", "content": " apparently adds enough overhead to make it go from a couple minutes to 15-20, even when using ", "images": []},
{"title": "missing", "links": "missing", "content": " on a 16-core machine. The bottleneck is never where you expect it.", "images": []},
{"title": "missing", "links": "missing", "content": "About 300,000 ", "images": []},
{"title": "missing", "links": "missing", "content": "\u2019s later, as well as some fleeting error messages from ", "images": []},
{"title": "missing", "links": "missing", "content": " about being unable to parse files correctly that may or may not be interesting to someone someday, we have some results. Unsurprisingly, of course, the ", "images": []},
{"title": "missing", "links": "missing", "content": " version finishes first and ", "images": []},
{"title": "missing", "links": "missing", "content": " looks something like this:", "images": []},
{"title": "missing", "links": "missing", "content": "Some spot-checking looks correct, so we can just sort it and have our DLL usage counts:", "images": []},
{"title": "missing", "links": "missing", "content": "The bottom of it looks like this:", "images": []},
{"title": "missing", "links": "missing", "content": "So, the most DLL-hungry program on the system uses 298 DLL\u2019s, and there appears to be another exponential-dropoff-ish frequency distribution to it. Great. Now, hmmm\u2026", "images": []},
{"title": "missing", "links": "missing", "content": "This produces a file like this:", "images": []},
{"title": "missing", "links": "missing", "content": "The first column is how many exe files use that number of DLL\u2019s, and the second column is how many DLL\u2019s it uses. So for example there are 160 executables that use exactly 27 DLL\u2019s. Eeeeexcellent. Time for some graphs!", "images": []},
{"title": "missing", "links": "missing", "content": "First off, the number of DLL\u2019s each exe uses. The X axis is just the exe, this is the data from the ", "images": []},
{"title": "missing", "links": "missing", "content": " we just produced. As expected it looks vaguely exponential, though there\u2019s a couple humps and bumps in there.", "images": []},
{"title": "missing", "links": "missing", "content": "Fig 1: DLL\u2019s used per file", "images": []},
{"title": "missing", "links": "missing", "content": "Now let\u2019s look at ", "images": []},
{"title": "missing", "links": "missing", "content": ", how many files are using 1 dll, how many are using 2, how many are using 3, etc. The Y axis got really crunched so I made it logarithmic. Because it was late at night, for some reason I used the natural logarithm. So as you can see there are about ", "images": []},
{"title": "missing", "links": "missing", "content": " executables that use ~5ish DLL\u2019s (about 5000), then a linear-ish-if-you-squint descent to ~3ish executables using ~150 DLL\u2019s, and then a bit of a bumpy long tail after that.", "images": []},
{"title": "missing", "links": "missing", "content": "Fig 2: DLL frequency", "images": []},
{"title": "missing", "links": "missing", "content": "We\u2019re sort of ascending through this data in reverse order, so the last thing to look at is how many times each individual DLL is used. This is sort of the flip side of Fig 1, and again there was a huge and weird spread of values so I made the Y axis a natural log. Very surprisingly though, it\u2019s still upward-curving\u2026 it\u2019s a ", "images": []},
{"title": "missing", "links": "missing", "content": " distribution. Don\u2019t see those very often! So there\u2019s a bunch of DLL\u2019s that are used 1 time, of course, but the more popular DLL\u2019s get more popular ", "images": []},
{"title": "missing", "links": "missing", "content": " quickly.", "images": []},
{"title": "missing", "links": "missing", "content": "Fig 3: Number of times each DLL is used", "images": []},
{"title": "missing", "links": "missing", "content": "It would have been nice to do a frequency graph of Fig 3, the same as I did with Fig 1 and Fig 2, but I forgot so you\u2019ll just have to imagine it.", "images": []},
{"title": "missing", "links": "missing", "content": "So, we now know how many times each DLL is used on this system, and how many DLL\u2019s each executable uses. Can we do anything actually useful with this data?", "images": []},
{"title": "missing", "links": "missing", "content": "We can measure how much hard disk space the DLL\u2019s save vs.\u00a0static linking. This will be an upper bound, since static linking doesn\u2019t necessarily include unused code from a library into an executable, while the DLL doesn\u2019t know what code will and will not be used.", "images": []},
{"title": "missing", "links": "missing", "content": "This should be pretty easy, we go to our ", "images": []},
{"title": "missing", "links": "missing", "content": " and just multiply our counts by the size of each DLL\u2026 except we didn\u2019t store the full path for each DLL. Okayyyy, we need to go back to our ", "images": []},
{"title": "missing", "links": "missing", "content": " and pull out the full paths instead of just the file names:", "images": []},
{"title": "missing", "links": "missing", "content": "This is not actually accurate because our basic ", "images": []},
{"title": "missing", "links": "missing", "content": " selection doesn\u2019t actually parse the output completely correctly, but will hopefully be somewhere in the right range. So we have to rerun our count again and generate a file of counts for full paths:", "images": []},
{"title": "missing", "links": "missing", "content": "This gets us a slightly screwy file that looks like this:", "images": []},
{"title": "missing", "links": "missing", "content": "As you can see, our ", "images": []},
{"title": "missing", "links": "missing", "content": " call left some artifacts, and it doesn\u2019t quiiiite match our previous ", "images": []},
{"title": "missing", "links": "missing", "content": " for Various Reasons. You think that there\u2019s only one ", "images": []},
{"title": "missing", "links": "missing", "content": " on your system? Pshaw, I have ", "images": []},
{"title": "missing", "links": "missing", "content": ". If we were doing shit Right we would have this in a script already and edit it to take out those artifacts; certainly if I ever wanted to reproduce this data set that would be the way to go. Instead I am just gonna edit the file and remove things that aren\u2019t absolute paths.", "images": []},
{"title": "missing", "links": "missing", "content": "(Random sidenote: notice that ", "images": []},
{"title": "missing", "links": "missing", "content": " isn\u2019t in this list. That\u2019s because it\u2019s not a real file, but rather a little chunk of code that the Linux kernel puts into every process to make life a little easier for libc or whatever to make certain system calls. See ", "images": []},
{"title": "missing", "links": "missing", "content": " for more info.)", "images": []},
{"title": "missing", "links": "missing", "content": "Ok, so NOW we can easily find the size of the files. Like fucking hell I\u2019m gonna try that in bash, and it\u2019s a bright shiny new day, so I finally am going to resort to Python:", "images": []},
{"title": "missing", "links": "missing", "content": "Mannnnn, what a cruel and terrible language, forcing us to care about crazy things like ", "images": []},
{"title": "missing", "links": "missing", "content": " and ", "images": []},
{"title": "missing", "links": "missing", "content": ". How dare it not cover up our mistakes for us.", "images": []},
{"title": "missing", "links": "missing", "content": "Run that sucker and sort the output in descending order:", "images": []},
{"title": "missing", "links": "missing", "content": "The first line with no file name is our sum total of ", "images": []},
{"title": "missing", "links": "missing", "content": " * ", "images": []},
{"title": "missing", "links": "missing", "content": ", and it is 155947508820 bytes, or about 145 gigabytes. This seems high to me, but a) this is an upper bound, and b) the numbers don\u2019t lie, right? ", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": " And, about 78 GB of that, more than half the total, is saved by the top 10 in this list. That surprises me, though looking back at Fig 3 it makes sense.", "images": []},
{"title": "missing", "links": "missing", "content": "For reference, the total non-", "images": []},
{"title": "missing", "links": "missing", "content": " data on this computer\u2019s root filesystem is about 33 GB. And it\u2019s a terabyte hard drive that isn\u2019t even half full, and I have fast internet to do software updates, so all this is mostly irrelevant to me in practice.", "images": []},
{"title": "missing", "links": "missing", "content": "Potential bug: I\u2019m not sure whether Python\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " follows symlinks, or just gives us the size of the symlink. So this may be all screwy, though I\u2019d expect the resulting sizes to be a lot smaller if it is. Fortunately it\u2019s easy enough to spot check:", "images": []},
{"title": "missing", "links": "missing", "content": "So ", "images": []},
{"title": "missing", "links": "missing", "content": " is 1,835,120 and is used 13,134 times, multiply those together and we get 24,102,466,080, the same number of bytes our program reports for ", "images": []},
{"title": "missing", "links": "missing", "content": ". So whew, we are fine.", "images": []},
{"title": "missing", "links": "missing", "content": "We can measure how much RAM the DLL\u2019s save vs.\u00a0static linking. This will also be an upper bound, since OS\u2019s don\u2019t necessarily page the entire DLL into memory at once, AFAIK they generally just page in sections of it lazily as they are actually used, and copy-on-write any data that is mutated. This needs a corpus of programs that are actually usually running though, which is more data to collect. On the flip side this is pretty realistic; I don\u2019t know about anyone else, but I have my computers set up to start a fixed set of programs every time they boot, and I generally use those programs every day. On the flip side, I have 16 GB of RAM in my desktop and almost never use more than half of it.", "images": []},
{"title": "missing", "links": "missing", "content": "So let\u2019s get a count of how many instances of each process I\u2019m running on my machine:", "images": []},
{"title": "missing", "links": "missing", "content": "However, it is now clear that we now need three different data tables for this analysis: the programs running, the DLL\u2019s used per program, and the bytes used per DLL. Unfortunately this is really getting to the point where the best tool for the job is a relational database, and I promised myself I wouldn\u2019t go that deep. So I\u2019m going to leave this as an exercise to the reader.", "images": []},
{"title": "missing", "links": "missing", "content": "Draw your own.", "images": []},
{"title": "missing", "links": "missing", "content": "No? Here\u2019s some to start with:", "images": []},
{"title": "missing", "links": "missing", "content": "Hey, we actually got a result or two that were surprising! However, I think this sort of data set has a lot of potential for going deeper. Someone should do that, and make a proper database that they can pull queries out of and such. But it probably won\u2019t be me, at least not any time soon. So here some other things I think would be interesting for that hypothetical person to explore:", "images": []},
{"title": "missing", "links": "missing", "content": "What interesting stuff ", "images": []},
{"title": "missing", "links": "missing", "content": " we investigate with this kind of approach?", "images": []},
{"title": "missing", "links": "missing", "content": "So huzzah, you now have some real data for your next Internet Argument, and you know how to (badly) collect more if you didn\u2019t know that already. Go get to work.", "images": []}
][
{"title": "Introduction", "links": "/_login", "content": "This is entirely the fault of a friend complaining about trying to move software between different versions of RHEL. I don\u2019t know why I\u2019m doing this, but it seemed like a good idea at the time. Why is this page named what it is? No idea. This was done in Jan 2022.", "images": []},
{"title": "Problem", "links": "/_logout", "content": "People have Opinions about DLL\u2019s these days. (I know Linux calls them shared objects, but that\u2019s a dumb name, so I\u2019ll call them DLL\u2019s.) DLL\u2019s add a level of complexity to writing and using software, and newer languages like Rust and Go have eschewed them, while Alpine Linux and maybe some other distributions also just don\u2019t bother using them. On the other hand, they exist for a reason, ie sharing compiled code with a common ABI between multiple programs. This has produced a fair amount of discourse the last few years asking interesting questions: Are they necessary? Are they useful? Are they worth the trouble? Can we reinvent the linking process to make the whole system better? These conversations tend to have a lot of Opinion to them and not much actual data, so let\u2019s start collecting data.", "images": []},
{"title": "Count uses per DLL", "links": "/_login", "content": "What data do we collect? Well, I am going to be looking at my everyday Linux system, an x86_64 desktop running Debian Bookworm. This is a quick-and-dirty survey: I want to do this analysis in like 90 minutes or so, and I will never do much with the results beyond going \u201chmm, that\u2019s neat\u201d. For the data I want it would probably be best to make a small sqlite database, import everything under the sun into it, and then have a set of SQL queries to do the actual analysis, but I don\u2019t particularly like SQL and have to re-learn it every time I use it, so that would take Time. Next best bet would be to write a pipeline in Python or Julia or something and use either CSV or JSON files as intermediate products, but I\u2019m bored of Python and don\u2019t feel like learning Julia right now, so I\u2019m not going to do that either. Hence if I can\u2019t do something with shell scripting, I\u2019m not going to do it.", "images": []},
{"title": "Count DLL\u2019s per file", "links": "/_logout", "content": "Also note I have a bit of background in data science, but was never terribly good at it, so I\u2019m just doing this for fun. Hence I will write this process down tutorial-style in the hopes of it being interesting to others, or in case someone dares try to reproduce the process. If you\u2019re not interested in the process, just skip to the bottom of each section for the conclusions. The overall question we are trying to answer here is: \u201cHow useful are DLL\u2019s?\u201d This data will not answer that question, but may let us start measuring some pieces of it.", "images": []},
{"title": "Graphs!", "links": "/Dllicious", "content": "Easy things first. How often is each DLL in the system actually used?", "images": []},
{"title": "Analysis", "links": "/_edit/Dllicious", "content": "First, we find all executable files:", "images": []},
{"title": "Conclusions", "links": "/_history/Dllicious", "content": "(make sure you don\u2019t have any remote filesystems mounted unless you want to wait, or give the ", "images": []},
{"title": "Future work", "links": "/_discuss/Dllicious", "content": " option to ", "images": []},
{"title": "missing", "links": "/Dllicious", "content": ", though that won\u2019t do what you want if you have say ", "images": []},
{"title": "missing", "links": "#introduction", "content": " and ", "images": []},
{"title": "missing", "links": "#problem", "content": " on separate drives.", "images": []},
{"title": "missing", "links": "#count-uses-per-dll", "content": "How many executable files do we have?", "images": []},
{"title": "missing", "links": "#count-dlls-per-file", "content": "Ok. Do we have any duplicates?", "images": []},
{"title": "missing", "links": "#graphs", "content": "We don\u2019t, good.", "images": []},
{"title": "missing", "links": "#analysis", "content": "Run ", "images": []},
{"title": "missing", "links": "#disk-space", "content": " on all files in parallel and save the results:", "images": []},
{"title": "missing", "links": "#memory", "content": "If the file is not an ELF executable then it will output ", "images": []},
{"title": "missing", "links": "#conclusions", "content": " to stderr, not stdout, so we\u2019re gucci, that won\u2019t go into our data file. If the file is an ELF executable that uses no DLL\u2019s, it will output ", "images": []},
{"title": "missing", "links": "#future-work", "content": " to stdout, so we can keep track of those too if we want.", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Zipf%27s_law", "content": "The ", "images": []},
{"title": "missing", "links": "https://bugs.python.org/issue38980", "content": " file looks like this:", "images": []},
{"title": "missing", "links": "/_category/computer", "content": "Snip off everything that doesn\u2019t start with a space:", "images": []},
{"title": "missing", "links": "/_category/badideas", "content": "Now it looks like this:", "images": []},
{"title": "missing", "links": "http://github.com/jgm/gitit/tree/master/", "content": "We only care about the DLL symbol name, so chop off everything after the first non-leading space:", "images": []},
{"title": "missing", "links": "/", "content": "Ok, how many lines are in there?", "images": []},
{"title": "missing", "links": "/", "content": "So all the DLL\u2019s on the system put together are used 208,000 times. This is a sort of weird measurement, it\u2019s \u201cthe sum of the count of the DLL\u2019s used by each executable\u201d. Let\u2019s turn it into something more handy, a frequency count of how many times each DLL is used.", "images": []},
{"title": "missing", "links": "/_index", "content": "So there are 1654 separate DLL\u2019s used on this system. Eyeballing the ", "images": []},
{"title": "missing", "links": "/_categories", "content": " file, the top of it looks like this:", "images": []},
{"title": "missing", "links": "/_random", "content": "And the bottom of it looks like this:", "images": []},
{"title": "missing", "links": "/_activity", "content": "So we now know how many times each DLL is used on the system. There are some artifacts in there, I\u2019m not sure happened to give us a DLL named ", "images": []},
{"title": "missing", "links": "/_upload", "content": " or ", "images": []},
{"title": "missing", "links": "/Help", "content": "; obviously something in our text processing step mangled some names. Taking 30 seconds to eyeball the file doesn\u2019t turn up too many other implausible-looking things, so I don\u2019t care. This is our quick-and-dirty pass after all.", "images": []},
{"title": "missing", "links": "/_showraw/Dllicious", "content": "Another anomaly worth keeping track of is statically linked executables. Our lame string-processing approach means that the ", "images": []},
{"title": "missing", "links": "/Dllicious?printable", "content": " output of ", "images": []},
{"title": "missing", "links": "/_delete/Dllicious", "content": " gets conveniently preserved and tallied up like any other DLL:", "images": []},
{"title": "missing", "links": "missing", "content": "I didn\u2019t expect many statically linked executables, but I did expect more than that.", "images": []},
{"title": "missing", "links": "missing", "content": "Anyway, not terribly surprisingly, it appears that there\u2019s a handful of DLL\u2019s that are used by almost everything, a pretty steep decline, and then it tapers off into a long tail. I\u2019d expect it to be something like an exponential dropoff, because ", "images": []},
{"title": "missing", "links": "missing", "content": ". We might dig a bit more into this data set later, but I tend to prefer to do a breadth-first search on these sorts of problems. Touch a lot of little things lightly, then go back and decide what to dig further into.", "images": []},
{"title": "missing", "links": "missing", "content": "Ok, so we now know how many times each DLL is used. Let\u2019s do the inverse as well, and find out how many DLL\u2019s each executable uses. To do this we have to go allll the way back to ", "images": []},
{"title": "missing", "links": "missing", "content": ". This is why, whenever you do data science, you either script the whole process at once, or you keep every intermediate data product and write down exactly how it\u2019s produced like I\u2019m doing right now.", "images": []},
{"title": "missing", "links": "missing", "content": "We can\u2019t feed a shell pipeline into xargs, so I can\u2019t just do ", "images": []},
{"title": "missing", "links": "missing", "content": " or something. Easy way around is to make a shell script that outputs the data we are interested in. So:", "images": []},
{"title": "missing", "links": "missing", "content": "Then we just run", "images": []},
{"title": "missing", "links": "missing", "content": "and it bombs out early for some reason. A little digging through the output turns up the error message ", "images": []},
{"title": "missing", "links": "missing", "content": ", so unsurprisingly a single-quote in a file name somewhere is totally hosing our shell script. This is where a sane person would drop bash like the live grenade it is; a few minutes of trying to make the ", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": " option cooperate results in it stubbornly saying ", "images": []},
{"title": "missing", "links": "missing", "content": ", which is just so helpful. Eyeballing the data file however, we can find that most instances of single or double quotes are music or data files that are accidentally marked executable, so we can just get rid of them:", "images": []},
{"title": "missing", "links": "missing", "content": "Sorry ", "images": []},
{"title": "missing", "links": "missing", "content": ", we will not find out how many DLL\u2019s you need linked into your program space when started.", "images": []},
{"title": "missing", "links": "missing", "content": "Ok but my bash script is now breaking on files that have spaces in their names, which is quite a lot of them. OF COURSE. Most of those files are probably unimportant, but there\u2019s enough of them in odd places that I don\u2019t want to filter them out or spot check them or such. FINE, we\u2019ll do it the STUPID and SLOW way, since I\u2019m sick of Python in my life and I don\u2019t feel like spending the afternoon learning Julia and ", "images": []},
{"title": "missing", "links": "missing", "content": " might or might not be able to fix the problem but this works dammit:", "images": []},
{"title": "missing", "links": "missing", "content": "Great, now the file looks like this:", "images": []},
{"title": "missing", "links": "missing", "content": "The first number is the number of dll\u2019s, and 0 means \u201cnot an ELF executable\u201d. So we snip out everything ending with ", "images": []},
{"title": "missing", "links": "missing", "content": " and remove empty newlines:", "images": []},
{"title": "missing", "links": "missing", "content": "Great, now we have this:", "images": []},
{"title": "missing", "links": "missing", "content": "Let\u2019s use awk to just turn it into ", "images": []},
{"title": "missing", "links": "missing", "content": " so we can sort it sanely:", "images": []},
{"title": "missing", "links": "missing", "content": "FAK that ALSO fucks up on filenames with spaces in them. This is why you shouldn\u2019t use shell for anything fancy, folks. Okay, let\u2019s change our ", "images": []},
{"title": "missing", "links": "missing", "content": " script to do the filtering itself, and output the count first because we know that will just be a number with no heckin\u2019 spaces or quotes or any other BS in it:", "images": []},
{"title": "missing", "links": "missing", "content": "GREAT now it works and we\u2019ve also eliminated an extra step. Fucking hell. Let\u2019s run our slow and terrible brute force loop again:", "images": []},
{"title": "missing", "links": "missing", "content": "Well that seems to be working, but pretty slowly. While it\u2019s running I might as well try to make ", "images": []},
{"title": "missing", "links": "missing", "content": " handle the stupid thing to see if I can make it use all my cores. If I can figure out the correct ", "images": []},
{"title": "missing", "links": "missing", "content": " invocation before the for loop finishes, it wins.", "images": []},
{"title": "missing", "links": "missing", "content": "Hey, that was easier than expected. However, this is still the part where you go get a cup of tea, maybe a sandwich, and possibly do some push-ups. The first ", "images": []},
{"title": "missing", "links": "missing", "content": " run processed a similar amount of data in similar ways, but the pipeline and such in ", "images": []},
{"title": "missing", "links": "missing", "content": " apparently adds enough overhead to make it go from a couple minutes to 15-20, even when using ", "images": []},
{"title": "missing", "links": "missing", "content": " on a 16-core machine. The bottleneck is never where you expect it.", "images": []},
{"title": "missing", "links": "missing", "content": "About 300,000 ", "images": []},
{"title": "missing", "links": "missing", "content": "\u2019s later, as well as some fleeting error messages from ", "images": []},
{"title": "missing", "links": "missing", "content": " about being unable to parse files correctly that may or may not be interesting to someone someday, we have some results. Unsurprisingly, of course, the ", "images": []},
{"title": "missing", "links": "missing", "content": " version finishes first and ", "images": []},
{"title": "missing", "links": "missing", "content": " looks something like this:", "images": []},
{"title": "missing", "links": "missing", "content": "Some spot-checking looks correct, so we can just sort it and have our DLL usage counts:", "images": []},
{"title": "missing", "links": "missing", "content": "The bottom of it looks like this:", "images": []},
{"title": "missing", "links": "missing", "content": "So, the most DLL-hungry program on the system uses 298 DLL\u2019s, and there appears to be another exponential-dropoff-ish frequency distribution to it. Great. Now, hmmm\u2026", "images": []},
{"title": "missing", "links": "missing", "content": "This produces a file like this:", "images": []},
{"title": "missing", "links": "missing", "content": "The first column is how many exe files use that number of DLL\u2019s, and the second column is how many DLL\u2019s it uses. So for example there are 160 executables that use exactly 27 DLL\u2019s. Eeeeexcellent. Time for some graphs!", "images": []},
{"title": "missing", "links": "missing", "content": "First off, the number of DLL\u2019s each exe uses. The X axis is just the exe, this is the data from the ", "images": []},
{"title": "missing", "links": "missing", "content": " we just produced. As expected it looks vaguely exponential, though there\u2019s a couple humps and bumps in there.", "images": []},
{"title": "missing", "links": "missing", "content": "Fig 1: DLL\u2019s used per file", "images": []},
{"title": "missing", "links": "missing", "content": "Now let\u2019s look at ", "images": []},
{"title": "missing", "links": "missing", "content": ", how many files are using 1 dll, how many are using 2, how many are using 3, etc. The Y axis got really crunched so I made it logarithmic. Because it was late at night, for some reason I used the natural logarithm. So as you can see there are about ", "images": []},
{"title": "missing", "links": "missing", "content": " executables that use ~5ish DLL\u2019s (about 5000), then a linear-ish-if-you-squint descent to ~3ish executables using ~150 DLL\u2019s, and then a bit of a bumpy long tail after that.", "images": []},
{"title": "missing", "links": "missing", "content": "Fig 2: DLL frequency", "images": []},
{"title": "missing", "links": "missing", "content": "We\u2019re sort of ascending through this data in reverse order, so the last thing to look at is how many times each individual DLL is used. This is sort of the flip side of Fig 1, and again there was a huge and weird spread of values so I made the Y axis a natural log. Very surprisingly though, it\u2019s still upward-curving\u2026 it\u2019s a ", "images": []},
{"title": "missing", "links": "missing", "content": " distribution. Don\u2019t see those very often! So there\u2019s a bunch of DLL\u2019s that are used 1 time, of course, but the more popular DLL\u2019s get more popular ", "images": []},
{"title": "missing", "links": "missing", "content": " quickly.", "images": []},
{"title": "missing", "links": "missing", "content": "Fig 3: Number of times each DLL is used", "images": []},
{"title": "missing", "links": "missing", "content": "It would have been nice to do a frequency graph of Fig 3, the same as I did with Fig 1 and Fig 2, but I forgot so you\u2019ll just have to imagine it.", "images": []},
{"title": "missing", "links": "missing", "content": "So, we now know how many times each DLL is used on this system, and how many DLL\u2019s each executable uses. Can we do anything actually useful with this data?", "images": []},
{"title": "missing", "links": "missing", "content": "We can measure how much hard disk space the DLL\u2019s save vs.\u00a0static linking. This will be an upper bound, since static linking doesn\u2019t necessarily include unused code from a library into an executable, while the DLL doesn\u2019t know what code will and will not be used.", "images": []},
{"title": "missing", "links": "missing", "content": "This should be pretty easy, we go to our ", "images": []},
{"title": "missing", "links": "missing", "content": " and just multiply our counts by the size of each DLL\u2026 except we didn\u2019t store the full path for each DLL. Okayyyy, we need to go back to our ", "images": []},
{"title": "missing", "links": "missing", "content": " and pull out the full paths instead of just the file names:", "images": []},
{"title": "missing", "links": "missing", "content": "This is not actually accurate because our basic ", "images": []},
{"title": "missing", "links": "missing", "content": " selection doesn\u2019t actually parse the output completely correctly, but will hopefully be somewhere in the right range. So we have to rerun our count again and generate a file of counts for full paths:", "images": []},
{"title": "missing", "links": "missing", "content": "This gets us a slightly screwy file that looks like this:", "images": []},
{"title": "missing", "links": "missing", "content": "As you can see, our ", "images": []},
{"title": "missing", "links": "missing", "content": " call left some artifacts, and it doesn\u2019t quiiiite match our previous ", "images": []},
{"title": "missing", "links": "missing", "content": " for Various Reasons. You think that there\u2019s only one ", "images": []},
{"title": "missing", "links": "missing", "content": " on your system? Pshaw, I have ", "images": []},
{"title": "missing", "links": "missing", "content": ". If we were doing shit Right we would have this in a script already and edit it to take out those artifacts; certainly if I ever wanted to reproduce this data set that would be the way to go. Instead I am just gonna edit the file and remove things that aren\u2019t absolute paths.", "images": []},
{"title": "missing", "links": "missing", "content": "(Random sidenote: notice that ", "images": []},
{"title": "missing", "links": "missing", "content": " isn\u2019t in this list. That\u2019s because it\u2019s not a real file, but rather a little chunk of code that the Linux kernel puts into every process to make life a little easier for libc or whatever to make certain system calls. See ", "images": []},
{"title": "missing", "links": "missing", "content": " for more info.)", "images": []},
{"title": "missing", "links": "missing", "content": "Ok, so NOW we can easily find the size of the files. Like fucking hell I\u2019m gonna try that in bash, and it\u2019s a bright shiny new day, so I finally am going to resort to Python:", "images": []},
{"title": "missing", "links": "missing", "content": "Mannnnn, what a cruel and terrible language, forcing us to care about crazy things like ", "images": []},
{"title": "missing", "links": "missing", "content": " and ", "images": []},
{"title": "missing", "links": "missing", "content": ". How dare it not cover up our mistakes for us.", "images": []},
{"title": "missing", "links": "missing", "content": "Run that sucker and sort the output in descending order:", "images": []},
{"title": "missing", "links": "missing", "content": "The first line with no file name is our sum total of ", "images": []},
{"title": "missing", "links": "missing", "content": " * ", "images": []},
{"title": "missing", "links": "missing", "content": ", and it is 155947508820 bytes, or about 145 gigabytes. This seems high to me, but a) this is an upper bound, and b) the numbers don\u2019t lie, right? ", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": " And, about 78 GB of that, more than half the total, is saved by the top 10 in this list. That surprises me, though looking back at Fig 3 it makes sense.", "images": []},
{"title": "missing", "links": "missing", "content": "For reference, the total non-", "images": []},
{"title": "missing", "links": "missing", "content": " data on this computer\u2019s root filesystem is about 33 GB. And it\u2019s a terabyte hard drive that isn\u2019t even half full, and I have fast internet to do software updates, so all this is mostly irrelevant to me in practice.", "images": []},
{"title": "missing", "links": "missing", "content": "Potential bug: I\u2019m not sure whether Python\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " follows symlinks, or just gives us the size of the symlink. So this may be all screwy, though I\u2019d expect the resulting sizes to be a lot smaller if it is. Fortunately it\u2019s easy enough to spot check:", "images": []},
{"title": "missing", "links": "missing", "content": "So ", "images": []},
{"title": "missing", "links": "missing", "content": " is 1,835,120 and is used 13,134 times, multiply those together and we get 24,102,466,080, the same number of bytes our program reports for ", "images": []},
{"title": "missing", "links": "missing", "content": ". So whew, we are fine.", "images": []},
{"title": "missing", "links": "missing", "content": "We can measure how much RAM the DLL\u2019s save vs.\u00a0static linking. This will also be an upper bound, since OS\u2019s don\u2019t necessarily page the entire DLL into memory at once, AFAIK they generally just page in sections of it lazily as they are actually used, and copy-on-write any data that is mutated. This needs a corpus of programs that are actually usually running though, which is more data to collect. On the flip side this is pretty realistic; I don\u2019t know about anyone else, but I have my computers set up to start a fixed set of programs every time they boot, and I generally use those programs every day. On the flip side, I have 16 GB of RAM in my desktop and almost never use more than half of it.", "images": []},
{"title": "missing", "links": "missing", "content": "So let\u2019s get a count of how many instances of each process I\u2019m running on my machine:", "images": []},
{"title": "missing", "links": "missing", "content": "However, it is now clear that we now need three different data tables for this analysis: the programs running, the DLL\u2019s used per program, and the bytes used per DLL. Unfortunately this is really getting to the point where the best tool for the job is a relational database, and I promised myself I wouldn\u2019t go that deep. So I\u2019m going to leave this as an exercise to the reader.", "images": []},
{"title": "missing", "links": "missing", "content": "Draw your own.", "images": []},
{"title": "missing", "links": "missing", "content": "No? Here\u2019s some to start with:", "images": []},
{"title": "missing", "links": "missing", "content": "Hey, we actually got a result or two that were surprising! However, I think this sort of data set has a lot of potential for going deeper. Someone should do that, and make a proper database that they can pull queries out of and such. But it probably won\u2019t be me, at least not any time soon. So here some other things I think would be interesting for that hypothetical person to explore:", "images": []},
{"title": "missing", "links": "missing", "content": "What interesting stuff ", "images": []},
{"title": "missing", "links": "missing", "content": " we investigate with this kind of approach?", "images": []},
{"title": "missing", "links": "missing", "content": "So huzzah, you now have some real data for your next Internet Argument, and you know how to (badly) collect more if you didn\u2019t know that already. Go get to work.", "images": []}
]