
        Reso: A visual circuits programming language using pixels.
      Reso is a low-level circuit design language and simulator, inspired by things like Redstone, Conway's Game of Life, and Wireworld.An input program is a circuit described by a (bitmap) image.<br>When a Reso program is ran through the Reso simulator, it outputs another valid Reso program! Things get interesting when you iterate this process.While the simulator acts like a pure function, for performance reasons, it maintains state between iterations.Because images are valid circuits, you can copy-and-paste smaller components to build up more complex circuits using your favorite image editor!This implementation is (1) slow (it's in Python!) and (2) not-interactive (you can't edit circuits live!) I hope you can have fun with this despite those limitations.<br>:)TODO -- I should list the packages and Python version here!It is recommended to run  with flag  since the examples, slides, etc.<br>in this repository made it a bit heavy.This implementation of Reso supports command line usage.<br>Input is a single image, and outputs are iterations of the Reso simulation of the circuit described in the first image.Here's an example: Load ,  () 12 times, and  () the results to , , ...<br>, printing information  () along the way:If you only wanted to save the end result, add the "-o" flag, as such:And here is the full command-line usage:The palette is an important part of Reso! You can define a circuit using an image.<br>Any pixel with a color in this palette of eight colors has semantic meaning, any other color doesn't.For backwards compatibility with new functionality, we reserve a total of 48 colors.<br>(This is by convention and is not enforced by the Reso simulator.)  push their signals through .<br>There are three different colors of wire (orange, sapphire, and lime).<br>Input nodes pass these signals to  and .<br>Logic nodes are used to calculate the 'AND' or 'XOR' of every input signal, and push these on to .<br>The output nodes act as one big  gate, pushing the new signals out to wires.The colors of different wires don't have any significance.<br>They exist to make it easier to wire in 2D space, and to make it easier to keep track of which wire is which.Here's the full palette of colors that we consider "reserved".<br>Other colors are 'whitespace', i.e.<br>will not have any semantic significance.(Note: Don't sample directly from your web-browser! They don't always render colors reliably.)The Reso logo is actually a complete circuit in-and-of itself! Here is a small gif that explains what's going on, animated at 1/4th the speed (that is, one update every 2000ms):Despite all the tests and documentation, Reso is a proof-of-concept and there's a lot to be done before this could even be a little useful!Here are some neat ideas: I've been having a weird issue with some versions of The GIMP, where colors are saved or picked incorrectly.<br>Reso requires precise colors (e.g.<br> is a valid color but  is not.) Perhaps a flag to consider only the ~4 or so most-significant-bits per pixel, or to map colors within a certain range to their nearest one in the palette, would be useful? Self explanatory! No more fiddling with GIMP or ffmpeg.<br>Reso is really a graph computation model of a logical circuit, and images are a way to define that graph.<br>I want to better decouple that model, and make this a repository a better reference implementation.Specifically, we consider pixels to represent logical "resels" which can also be represented textually, and regions of resels represent elements, which are represented internally as a graph implemented with Python dictionaries.<br>But this graph isn't a standard, so a compiled graph can't be transferred between implementations.<br>Some kind of GUI would be nifty too, rather than requiring expertise in some external graphical application.<br>An interactive, Javascript webpage would make this a lot easier to mess around with, huh? This is also really slow.<br>Might reimplement in Rust when I get around to learning it! Porting this to a faster language would be great.<br>I think Rust would be fun (both because I want to learn it, and because there's some "Web Assembly" thing that makes me think it's easier to put Rust in the web than, say, C or C++.)Here are a list of similar projects that I am aware of.<br>Please make an issue or PR if you have something else to share!
      Reso: A visual circuits programming language using pixels.
    
        Reso: A visual circuits programming language using pixels.
      Reso is a low-level circuit design language and simulator, inspired by things like Redstone, Conway's Game of Life, and Wireworld.An input program is a circuit described by a (bitmap) image.<br>When a Reso program is ran through the Reso simulator, it outputs another valid Reso program! Things get interesting when you iterate this process.While the simulator acts like a pure function, for performance reasons, it maintains state between iterations.Because images are valid circuits, you can copy-and-paste smaller components to build up more complex circuits using your favorite image editor!This implementation is (1) slow (it's in Python!) and (2) not-interactive (you can't edit circuits live!) I hope you can have fun with this despite those limitations.<br>:)TODO -- I should list the packages and Python version here!It is recommended to run  with flag  since the examples, slides, etc.<br>in this repository made it a bit heavy.This implementation of Reso supports command line usage.<br>Input is a single image, and outputs are iterations of the Reso simulation of the circuit described in the first image.Here's an example: Load ,  () 12 times, and  () the results to , , ...<br>, printing information  () along the way:If you only wanted to save the end result, add the "-o" flag, as such:And here is the full command-line usage:The palette is an important part of Reso! You can define a circuit using an image.<br>Any pixel with a color in this palette of eight colors has semantic meaning, any other color doesn't.For backwards compatibility with new functionality, we reserve a total of 48 colors.<br>(This is by convention and is not enforced by the Reso simulator.)  push their signals through .<br>There are three different colors of wire (orange, sapphire, and lime).<br>Input nodes pass these signals to  and .<br>Logic nodes are used to calculate the 'AND' or 'XOR' of every input signal, and push these on to .<br>The output nodes act as one big  gate, pushing the new signals out to wires.The colors of different wires don't have any significance.<br>They exist to make it easier to wire in 2D space, and to make it easier to keep track of which wire is which.Here's the full palette of colors that we consider "reserved".<br>Other colors are 'whitespace', i.e.<br>will not have any semantic significance.(Note: Don't sample directly from your web-browser! They don't always render colors reliably.)The Reso logo is actually a complete circuit in-and-of itself! Here is a small gif that explains what's going on, animated at 1/4th the speed (that is, one update every 2000ms):Despite all the tests and documentation, Reso is a proof-of-concept and there's a lot to be done before this could even be a little useful!Here are some neat ideas: I've been having a weird issue with some versions of The GIMP, where colors are saved or picked incorrectly.<br>Reso requires precise colors (e.g.<br> is a valid color but  is not.) Perhaps a flag to consider only the ~4 or so most-significant-bits per pixel, or to map colors within a certain range to their nearest one in the palette, would be useful? Self explanatory! No more fiddling with GIMP or ffmpeg.<br>Reso is really a graph computation model of a logical circuit, and images are a way to define that graph.<br>I want to better decouple that model, and make this a repository a better reference implementation.Specifically, we consider pixels to represent logical "resels" which can also be represented textually, and regions of resels represent elements, which are represented internally as a graph implemented with Python dictionaries.<br>But this graph isn't a standard, so a compiled graph can't be transferred between implementations.<br>Some kind of GUI would be nifty too, rather than requiring expertise in some external graphical application.<br>An interactive, Javascript webpage would make this a lot easier to mess around with, huh? This is also really slow.<br>Might reimplement in Rust when I get around to learning it! Porting this to a faster language would be great.<br>I think Rust would be fun (both because I want to learn it, and because there's some "Web Assembly" thing that makes me think it's easier to put Rust in the web than, say, C or C++.)Here are a list of similar projects that I am aware of.<br>Please make an issue or PR if you have something else to share!
      Reso: A visual circuits programming language using pixels.
    </p>
