[
{"title": "Code Colocation is King", "links": "#content", "content": "Koen van Gilst / ", "images": []},
{"title": "missing", "links": "/", "content": "November 14, 2021", "images": []},
{"title": "missing", "links": "/portfolio", "content": "3 min read", "images": []},
{"title": "missing", "links": "/labs", "content": "One of the things I struggled with when I started out as a programmer was where to put my code. It was not something I could easily find in tutorials and for a long time I wondered why everyone was so focused on how to get framework X to do Y, when all I wanted to know was where to put the code that does Y.", "images": []},
{"title": "missing", "links": "/blog", "content": "Turns out that \"where to put code\" is one of the hard things in software engineering and there are no silver bullets. That's part of the reason why there are so few easy tutorials on this subject.", "images": []},
{"title": "missing", "links": "https://pragprog.com/titles/atevol/software-design-x-rays/", "content": "Most of the code structuring patterns out there (the MVC pattern or patterns recommended by libraries) make sense in their own way, but they often fail to tell you what to do in day-to-day cases. For instance, when you have a simple utility function that's only used in one place, where should you put it? In the global ", "images": []},
{"title": "missing", "links": "https://mobile.twitter.com/search?q=https%3A%2F%2Fkoenvangilst.nl%2Fblog%2Fcode-colocation-is-king", "content": " folder?", "images": []},
{"title": "missing", "links": "https://github.com/vnglst/koenvangilst.nl/edit/master/data/blog/code-colocation-is-king.mdx", "content": "Over the years I've learned that the following principle helps to structure code in way that's easy to understand and maintain: ", "images": []},
{"title": "missing", "links": "/", "content": ".", "images": []},
{"title": "missing", "links": "/about", "content": "This means that if you have a helper function that's specific for the feature you're writing in ", "images": []},
{"title": "missing", "links": "/dashboard", "content": " it's a good idea to keep this function close at hand. So put it either inside the ", "images": []},
{"title": "missing", "links": "/snippets", "content": " file or right next to it if you have several helper functions. This way, when you have to change or understand the functionality of featureA, all the code you need is close by.", "images": []},
{"title": "missing", "links": "/blog/collection-of-great-tweets", "content": "For this blog post I've chosen ", "images": []},
{"title": "missing", "links": "/credits", "content": " as a title, but it's more often called ", "images": []},
{"title": "missing", "links": "https://twitter.com/vnglst", "content": ":", "images": []},
{"title": "missing", "links": "https://github.com/vnglst", "content": "The principle of proximity focuses on how well organised your code is with respect to readability and change. Proximity implies that functions that are changed together are moved closer together. Proximity is both a design principle and a heuristic for refactoring hotspots toward code that's easier to understand.", "images": []},
{"title": "missing", "links": "https://www.linkedin.com/in/vangilst/", "content": "\u2014 ", "images": []},
{"title": "missing", "links": "https://github.com/vnglst/koenvangilst.nl/tree/a249a8b", "content": "So think about the Proximity Principle the next time you're in doubt:", "images": []},
{"title": "missing", "links": "missing", "content": "Like I said at the beginning of this post: There are no silver bullets for structuring code. And the proximity principle does not always tell you exactly where to put code. But when you're in doubt it tells you to keep code close to where it's relevant -- until you've found a good reason not to do so anymore.", "images": []}
][
{"title": "Code Colocation is King", "links": "#content", "content": "Koen van Gilst / ", "images": []},
{"title": "missing", "links": "/", "content": "November 14, 2021", "images": []},
{"title": "missing", "links": "/portfolio", "content": "3 min read", "images": []},
{"title": "missing", "links": "/labs", "content": "One of the things I struggled with when I started out as a programmer was where to put my code. It was not something I could easily find in tutorials and for a long time I wondered why everyone was so focused on how to get framework X to do Y, when all I wanted to know was where to put the code that does Y.", "images": []},
{"title": "missing", "links": "/blog", "content": "Turns out that \"where to put code\" is one of the hard things in software engineering and there are no silver bullets. That's part of the reason why there are so few easy tutorials on this subject.", "images": []},
{"title": "missing", "links": "https://pragprog.com/titles/atevol/software-design-x-rays/", "content": "Most of the code structuring patterns out there (the MVC pattern or patterns recommended by libraries) make sense in their own way, but they often fail to tell you what to do in day-to-day cases. For instance, when you have a simple utility function that's only used in one place, where should you put it? In the global ", "images": []},
{"title": "missing", "links": "https://news.ycombinator.com/item?id=30166318", "content": " folder?", "images": []},
{"title": "missing", "links": "https://mobile.twitter.com/search?q=https%3A%2F%2Fkoenvangilst.nl%2Fblog%2Fcode-colocation-is-king", "content": "Over the years I've learned that the following principle helps to structure code in way that's easy to understand and maintain: ", "images": []},
{"title": "missing", "links": "https://github.com/vnglst/koenvangilst.nl/edit/master/data/blog/code-colocation-is-king.mdx", "content": ".", "images": []},
{"title": "missing", "links": "/", "content": "This means that if you have a helper function that's specific for the feature you're writing in ", "images": []},
{"title": "missing", "links": "/about", "content": " it's a good idea to keep this function close at hand. So put it either inside the ", "images": []},
{"title": "missing", "links": "/dashboard", "content": " file or right next to it if you have several helper functions. This way, when you have to change or understand the functionality of featureA, all the code you need is close by.", "images": []},
{"title": "missing", "links": "/snippets", "content": "For this blog post I've chosen ", "images": []},
{"title": "missing", "links": "/blog/collection-of-great-tweets", "content": " as a title, but it's more often called ", "images": []},
{"title": "missing", "links": "/credits", "content": ":", "images": []},
{"title": "missing", "links": "https://twitter.com/vnglst", "content": "The principle of proximity focuses on how well organised your code is with respect to readability and change. Proximity implies that functions that are changed together are moved closer together. Proximity is both a design principle and a heuristic for refactoring hotspots toward code that's easier to understand.", "images": []},
{"title": "missing", "links": "https://github.com/vnglst", "content": "\u2014 ", "images": []},
{"title": "missing", "links": "https://www.linkedin.com/in/vangilst/", "content": "So think about the Proximity Principle the next time you're in doubt:", "images": []},
{"title": "missing", "links": "https://github.com/vnglst/koenvangilst.nl/tree/00e132d", "content": "Like I said at the beginning of this post: There are no silver bullets for structuring code. And the proximity principle does not always tell you exactly where to put code. But when you're in doubt it tells you to keep code close to where it's relevant -- until you've found a good reason not to do so anymore.", "images": []},
{"title": "missing", "links": "missing", "content": "This article reached the Hacker News front page on feb. 3rd 2022. It got a lot\nof good feedback there and I'd like to revisit this theme in a future post.\nUntil then be sure to ", "images": []},
{"title": "missing", "links": "missing", "content": " for some interesting\ncomments.", "images": []}
]