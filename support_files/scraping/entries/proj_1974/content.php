<p>I have written an offline TUI thesaurus that may be of interest to this community.<br>You can find at this .While I made it primarily for my own use and to practice several development ideas, I'd appreciate feedback from a wider audience:is it useful? is there something that would make it more useful?is it easy enough to use and understand?it runs on Linux and BSD, would Windows user even be interested?  (One might assume the question of whether Linux or BSD users was handled in my first question.)I debated with myself if this or the  subreddit was more appropriate.<br> Do people here generally comment on potentially bad practices with respect to makefiles, automatically downloading other resources, coding conventions, etc?  I tried to make the README.md be as transparent as possible as to what I'm doing in the makefile, but it might not be thorough enough, or it might not be prominent enough.I would be grateful for any comments.Instead of sprintfing a temporary format, show_words could use variable field lengthYour makefile hangs with no output from a fresh git clone.I developed it on Manjaro and FreeBSD.<br> I was trying to create one makefile that works on both, so it might be more fragile than I realized.<br> What environment are you using?Cool project and neat idea! I knew I was in for a treat when I saw the man page in the file listing.By strange coincidence, just last night I watched , and it reminded me that I've neglected keeping an offline thesaurus at hand.<br>I've been lazy, always going online even though the experience is so poor.I'm finding the benefit of reading an alphapetic list far outweighs the dubious benefit of trying to put more commonly-used words first.The alphabetic sorting was the very first thing that stood out.<br>I expected it to sort by relevance and frequency since that's what I find most useful.Despite all the hard work you put into it, the interactive interface seems… well… redundant.<br>This is a case where I'd just prefer a nice non-interactive program that lists results.<br>Using columns is smart, though.Your well-formed database is by far the most useful component for me.<br>Since GNU  can search the whole thing in about 20ms, I can just grep for what I want.<br>Getting results:This prints out a nice table, paging if necessary (with full  capabilities including built-in search, command history, etc.).<br>Doing a reverse, or "trunk" search as you call it:Putting it all together in a script (in my real script I'll probably make the entire thesaurus a heredoc):(If you don't have a convenient  command, I have my own version , where  is equivalent.) Examples:I might have better explained my preference for alphabetic order, but I thought the README was getting too long.<br> Here are a few of my reasons:When I'm searching for the best word from a list, I usually weigh my options more than once.<br> For me, alphabetic sorting was by far the easiest output to navigate this way.I attempted some relevance sorting.<br>I agree that this would be a significant upgrade for long lists.<br> I wanted to link definitions to thesaurus words in order to classify words by part-of-speech.<br> I spent a lot of time writing a script to convert symbols to unicode characters in a public domain dictionary.<br> Then it dawned on me that many words serve as various parts-of-speech.<br> In addition to the effort it would take to parse out the parts-of-speech data, I would have had to completely redesign the database and the query strategy, and face difficult choices with respect to pagination.<br> I decided that the extra value offered was not worth the extra work.I did include frequency sorting for a while.<br>I used two strategies: an online word frequency survey and the word frequency within the thesaurus.<br> Using this order made me question the its value: there's no obvious reason to prefer more- rather than less-frequently expressed words.<br> In the end, not being able to find previously considered words in a list with no apparent order led me to just stick with alphabetic order.The code also supports newspaper versus parallel columns, and I originally made this choice available.<br> I removed the option (in the interest of a simpler menu) because I found it much harder to scan parallel columns.It  a bit depressing that it is so easy to reproduce much of my program's utility with a simple shell script.<br> I do like explicit pagination for revisiting words, but it's only a minor upgrade over using  or another pager.<br> Nevertheless, my purpose in developing the program was to try out some TUI ideas, to develop some makefile mastery, to play with a key-store database, and to test my idea of organizing reusable components for new projects.<br> That it's been so useful to me has been a bonus, and because of that I thought it was a reasonable project with which to introduce myself to this subreddit.Just a remark:The Moby Thesaurus is already available in DICT format; thus it can already be queried from the command line.MembersOnlineI have written an offline TUI thesaurus that may be of interest to this community.<br>You can find at this .While I made it primarily for my own use and to practice several development ideas, I'd appreciate feedback from a wider audience:is it useful? is there something that would make it more useful?is it easy enough to use and understand?it runs on Linux and BSD, would Windows user even be interested?  (One might assume the question of whether Linux or BSD users was handled in my first question.)I debated with myself if this or the  subreddit was more appropriate.<br> Do people here generally comment on potentially bad practices with respect to makefiles, automatically downloading other resources, coding conventions, etc?  I tried to make the README.md be as transparent as possible as to what I'm doing in the makefile, but it might not be thorough enough, or it might not be prominent enough.I would be grateful for any comments.Instead of sprintfing a temporary format, show_words could use variable field lengthYour makefile hangs with no output from a fresh git clone.I developed it on Manjaro and FreeBSD.<br> I was trying to create one makefile that works on both, so it might be more fragile than I realized.<br> What environment are you using?Cool project and neat idea! I knew I was in for a treat when I saw the man page in the file listing.By strange coincidence, just last night I watched , and it reminded me that I've neglected keeping an offline thesaurus at hand.<br>I've been lazy, always going online even though the experience is so poor.I'm finding the benefit of reading an alphapetic list far outweighs the dubious benefit of trying to put more commonly-used words first.The alphabetic sorting was the very first thing that stood out.<br>I expected it to sort by relevance and frequency since that's what I find most useful.Despite all the hard work you put into it, the interactive interface seems… well… redundant.<br>This is a case where I'd just prefer a nice non-interactive program that lists results.<br>Using columns is smart, though.Your well-formed database is by far the most useful component for me.<br>Since GNU  can search the whole thing in about 20ms, I can just grep for what I want.<br>Getting results:This prints out a nice table, paging if necessary (with full  capabilities including built-in search, command history, etc.).<br>Doing a reverse, or "trunk" search as you call it:Putting it all together in a script (in my real script I'll probably make the entire thesaurus a heredoc):(If you don't have a convenient  command, I have my own version , where  is equivalent.) Examples:I might have better explained my preference for alphabetic order, but I thought the README was getting too long.<br> Here are a few of my reasons:When I'm searching for the best word from a list, I usually weigh my options more than once.<br> For me, alphabetic sorting was by far the easiest output to navigate this way.I attempted some relevance sorting.<br>I agree that this would be a significant upgrade for long lists.<br> I wanted to link definitions to thesaurus words in order to classify words by part-of-speech.<br> I spent a lot of time writing a script to convert symbols to unicode characters in a public domain dictionary.<br> Then it dawned on me that many words serve as various parts-of-speech.<br> In addition to the effort it would take to parse out the parts-of-speech data, I would have had to completely redesign the database and the query strategy, and face difficult choices with respect to pagination.<br> I decided that the extra value offered was not worth the extra work.I did include frequency sorting for a while.<br>I used two strategies: an online word frequency survey and the word frequency within the thesaurus.<br> Using this order made me question the its value: there's no obvious reason to prefer more- rather than less-frequently expressed words.<br> In the end, not being able to find previously considered words in a list with no apparent order led me to just stick with alphabetic order.The code also supports newspaper versus parallel columns, and I originally made this choice available.<br> I removed the option (in the interest of a simpler menu) because I found it much harder to scan parallel columns.It  a bit depressing that it is so easy to reproduce much of my program's utility with a simple shell script.<br> I do like explicit pagination for revisiting words, but it's only a minor upgrade over using  or another pager.<br> Nevertheless, my purpose in developing the program was to try out some TUI ideas, to develop some makefile mastery, to play with a key-store database, and to test my idea of organizing reusable components for new projects.<br> That it's been so useful to me has been a bonus, and because of that I thought it was a reasonable project with which to introduce myself to this subreddit.Just a remark:The Moby Thesaurus is already available in DICT format; thus it can already be queried from the command line.MembersOnline</p>
