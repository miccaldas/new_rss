<p>  
	 When a peer connects to an inetd-managed port, inetd runs a command in a sub process to handle the incoming request.<br>The sub process is given a socket file descriptor as standard input, standard output, and standard error.<br>Once the sub process is finished—for example, after printing a requested web page to its STDOUT—it exits, returning control to inetd.inetd is not a common part of deployments today, but it still has potential to be useful in production environments.inetd needs to be started by rc and enabled in rc.conf.<br>It has its own configuration file /etc/inetd.conf which contains a lot of example configurations.You can start inetd by adding an enable entry to rc.conf with sysrc and starting it with service:Inetd contains built-in versions of some services that don’t see much use anymore, but were common in the early days of the Internet.<br>The inetd.conf configuration file has example entries for a number of services, including the internal services it implements.<br>The four simple servers built into inetd on FreeBSD are:These internal services are good to test your configuration to verify that inetd is working, before using inetd to act as a socket activator for other traffic.Kernel development is crucial to many companies.<br>If you have a FreeBSD implementation or you’re looking at scoping out work for the future, our team can help you further enable your efforts.Daytime returns a pleasant response (unlike the noise that chargen does) when we connect to it.<br>For testing let’s enable the daytime internal services in /etc/inetd.conf:A host’s services are described in the /etc/services file, there we can see that daytime for tcp, udp and sctp runs on port 13.inetd reconfigures in response to SIGHUP and the service reload command.<br>After changing the configuration file and reloading, we will have inetd listening on port 13 and acting as a daytime server:We can test the services using netcat:To inetd, external services are any other process that it might launch. inetd.conf also contains examples of how to launch common services including ftp, sshd, telnet and fingerd.In the above examples, sshd needs to be given the -i flag to signify that it is being launched from inetd.<br>The telnetd service, on the other hand, does not:As we can see from its man page above, telnetd is intended to be launched from inetd and is not expected to be run standalone.<br>Although telnetd is strongly deprecated, some commonly used software—such as tftpd—is still deployed this way today.The power of inetd  lies in the simplicity of its interface.<br>To demonstrate, let’s create a simple inetd-managed service.<br>Since inetd handles the network connections, we can write our own daytime service shell script as simply as this:When our example script runs the date command, it prints the date to standard output.<br>When invoked from inetd, our script’s STDOUT is passed to inetd’s own socket—and inetd then passes our shell script’s output to the network peer which requested it.<br>This simple mechanism can also be used to read input from a host.Each line in the inetd configuration file describes the service to be provided (daytime), the type of socket to create (stream) and protocol (tcp), wait or nowait (explained below), the user to run the local command as (user), the full path of the local command to run (/home/user/daytime.sh) and an example command line including ARGV[0] (daytime.sh).<br>With this configuration, we can replace the internal daytime service with our shell script:This isn’t generally the best way to implement high performance, heavily trafficked services—but it can be a handy way to quickly expose simple commands to the network.<br>For example, one might use inetd to provide read-only sysctl variables to a logging tool.As with any network service, you should still be careful not to expose information—or the ability to run commands—to users who shouldn’t be able to access them.<br>This is especially true for any commands exposed to the entire Internet!waitvs nowaitIn the example configuration, each of the services is listed with either wait or nowait.<br>The tiny internal servers, the TCP services are marked nowait, but the UDP ones are marked wait.This indicator in the configuration file tells inetd what to do when it invokes the process to handle the connection.<br>With nowait inetd is being told that the invoked process is going to fork and handle the connection and inetd can pass that responsibility to the invoked process.The wait keyword tells inetd that it must wait until the invoked process terminates before handling new service requests.Stream (think TCP) services that use the nowait key word are expected to handle single client requests forwarded from inetd.<br>This is the expected mode of operation. wait stream services act as full servers and are instead given the listening socket and are expected to accept at least one connection from the socket before exiting.For datagram services there is a dance required to handle connections for services and it is more common to use wait to handle those services.<br>Datagram servers that use nowait should read at least one packet from the socket and connect(2) to the peer to create a binding in the kernel so they get packets correctly routed to them.inetd has evolved a lot since its first release in 4.3BSD.<br>You can get a rough idea of how much functionality it grew by comparing the  to the .inetd supports the ability to use the (now outdated)  protocol which enables multiplexing of services on a single port.<br>This is similar to a  that allows you to run non SSL services and multiplex them on a single application.An interesting historical point in inetd’s life was the introduction of the .<br>TCP wrappers were invented during one of the early hacker hunts,  of the hunt for this hacker is a great read, but shortly: The systems under attack were consistently being rooted and the attacker was running rm -rf destroying everything on the disk and making recovering logs very difficult.<br>With minimal development a shim was put between the services on the host and the application, the shim logged each connection to the host.The logging shim grew the ability to perform source access control for connections and was extended to perform a reverse finger (a look up of host/user on a remote machine).<br>While it didn’t help them catch the hacker (they stopped when they figured out they were being hunted), it did help them figure out where they were coming from and track the incidents over a number of networks spread across the planet.Since that incident tcp_wrappers grew to be more of an access control feature and are reminiscent of http application firewalls.<br>An interesting idea for their use was to remove (i.e. those generated by the ping command).For production uses today, it is worth exploring the rate limiting features that inetd has to offer.<br>inetd can be configured to rate limit with four different controls:At Klara, we have an entire team dedicated to helping you with your FreeBSD projects.<br>Whether you’re planning a FreeBSD project, or are in the middle of one and need a bit of extra insight, we’re here to help!Although inetd may seem quaint in 2022, its core concepts live on in Linux’s systemd and macOS’s launchd.  In particular, limiting the number of idle processes with inetd or a similar superserver is useful in tiny images intended for containers and tiny embedded devices.inetd also offers the ability to inject logic in the handling of connections to less often used services.<br>There are accounts of inetd being used to create jails, enabling single request execution environments.<br>While inetd might feel old, there are clear parallels in more modern software and it is an easily extendable building block.Tom Jones is an Internet Researcher and FreeBSD developer that works on improving the core protocols that drive the Internet.<br>He is acontributor to open standards in the IETF and is enthusiastic about using FreeBSD as a platform to experiment with new networking ideas as they progress towards standardisation.Kernel development is crucial to many companies.<br>If you have a FreeBSD implementation or you’re looking at scoping out work for the future, our team can help you further enable your efforts.FreeBSD can report on the health of the system and perform various routine maintenance tasks using its own built-in mechanism for periodically running scripts.<br>Learn about the periodic system and how to find available scripts, write your own scripts and where and how to apply them.Pot and Nomad are two tools intended to provide cluster provisioning on FreeBSD and replace tools like Docker and Kubernetes, which suffer from lack of sufficient support on FreeBSD.<br>Read how in this article.In his 1999 book In the Beginning… Was the Command Line, Neal Stephenson said the following about Unix: “Windows 95 and MacOS are products, contrived by engineers in the service of specific companies.<br>Unix, by contrast, is not so much a product as it is a painstakingly compiled oral history of the hacker subculture.<br>It is our Gilgamesh epic.”
Read more about how the story of UNIX actually goes.<br> Category: ,        Tags: , , Klara Inc.<br> 
	 When a peer connects to an inetd-managed port, inetd runs a command in a sub process to handle the incoming request.<br>The sub process is given a socket file descriptor as standard input, standard output, and standard error.<br>Once the sub process is finished—for example, after printing a requested web page to its STDOUT—it exits, returning control to inetd.inetd is not a common part of deployments today, but it still has potential to be useful in production environments.inetd needs to be started by rc and enabled in rc.conf.<br>It has its own configuration file /etc/inetd.conf which contains a lot of example configurations.You can start inetd by adding an enable entry to rc.conf with sysrc and starting it with service:Inetd contains built-in versions of some services that don’t see much use anymore, but were common in the early days of the Internet.<br>The inetd.conf configuration file has example entries for a number of services, including the internal services it implements.<br>The four simple servers built into inetd on FreeBSD are:These internal services are good to test your configuration to verify that inetd is working, before using inetd to act as a socket activator for other traffic.Kernel development is crucial to many companies.<br>If you have a FreeBSD implementation or you’re looking at scoping out work for the future, our team can help you further enable your efforts.Daytime returns a pleasant response (unlike the noise that chargen does) when we connect to it.<br>For testing let’s enable the daytime internal services in /etc/inetd.conf:A host’s services are described in the /etc/services file, there we can see that daytime for tcp, udp and sctp runs on port 13.inetd reconfigures in response to SIGHUP and the service reload command.<br>After changing the configuration file and reloading, we will have inetd listening on port 13 and acting as a daytime server:We can test the services using netcat:To inetd, external services are any other process that it might launch. inetd.conf also contains examples of how to launch common services including ftp, sshd, telnet and fingerd.In the above examples, sshd needs to be given the -i flag to signify that it is being launched from inetd.<br>The telnetd service, on the other hand, does not:As we can see from its man page above, telnetd is intended to be launched from inetd and is not expected to be run standalone.<br>Although telnetd is strongly deprecated, some commonly used software—such as tftpd—is still deployed this way today.The power of inetd  lies in the simplicity of its interface.<br>To demonstrate, let’s create a simple inetd-managed service.<br>Since inetd handles the network connections, we can write our own daytime service shell script as simply as this:When our example script runs the date command, it prints the date to standard output.<br>When invoked from inetd, our script’s STDOUT is passed to inetd’s own socket—and inetd then passes our shell script’s output to the network peer which requested it.<br>This simple mechanism can also be used to read input from a host.Each line in the inetd configuration file describes the service to be provided (daytime), the type of socket to create (stream) and protocol (tcp), wait or nowait (explained below), the user to run the local command as (user), the full path of the local command to run (/home/user/daytime.sh) and an example command line including ARGV[0] (daytime.sh).<br>With this configuration, we can replace the internal daytime service with our shell script:This isn’t generally the best way to implement high performance, heavily trafficked services—but it can be a handy way to quickly expose simple commands to the network.<br>For example, one might use inetd to provide read-only sysctl variables to a logging tool.As with any network service, you should still be careful not to expose information—or the ability to run commands—to users who shouldn’t be able to access them.<br>This is especially true for any commands exposed to the entire Internet!waitvs nowaitIn the example configuration, each of the services is listed with either wait or nowait.<br>The tiny internal servers, the TCP services are marked nowait, but the UDP ones are marked wait.This indicator in the configuration file tells inetd what to do when it invokes the process to handle the connection.<br>With nowait inetd is being told that the invoked process is going to fork and handle the connection and inetd can pass that responsibility to the invoked process.The wait keyword tells inetd that it must wait until the invoked process terminates before handling new service requests.Stream (think TCP) services that use the nowait key word are expected to handle single client requests forwarded from inetd.<br>This is the expected mode of operation. wait stream services act as full servers and are instead given the listening socket and are expected to accept at least one connection from the socket before exiting.For datagram services there is a dance required to handle connections for services and it is more common to use wait to handle those services.<br>Datagram servers that use nowait should read at least one packet from the socket and connect(2) to the peer to create a binding in the kernel so they get packets correctly routed to them.inetd has evolved a lot since its first release in 4.3BSD.<br>You can get a rough idea of how much functionality it grew by comparing the  to the .inetd supports the ability to use the (now outdated)  protocol which enables multiplexing of services on a single port.<br>This is similar to a  that allows you to run non SSL services and multiplex them on a single application.An interesting historical point in inetd’s life was the introduction of the .<br>TCP wrappers were invented during one of the early hacker hunts,  of the hunt for this hacker is a great read, but shortly: The systems under attack were consistently being rooted and the attacker was running rm -rf destroying everything on the disk and making recovering logs very difficult.<br>With minimal development a shim was put between the services on the host and the application, the shim logged each connection to the host.The logging shim grew the ability to perform source access control for connections and was extended to perform a reverse finger (a look up of host/user on a remote machine).<br>While it didn’t help them catch the hacker (they stopped when they figured out they were being hunted), it did help them figure out where they were coming from and track the incidents over a number of networks spread across the planet.Since that incident tcp_wrappers grew to be more of an access control feature and are reminiscent of http application firewalls.<br>An interesting idea for their use was to remove (i.e. those generated by the ping command).For production uses today, it is worth exploring the rate limiting features that inetd has to offer.<br>inetd can be configured to rate limit with four different controls:At Klara, we have an entire team dedicated to helping you with your FreeBSD projects.<br>Whether you’re planning a FreeBSD project, or are in the middle of one and need a bit of extra insight, we’re here to help!Although inetd may seem quaint in 2022, its core concepts live on in Linux’s systemd and macOS’s launchd.  In particular, limiting the number of idle processes with inetd or a similar superserver is useful in tiny images intended for containers and tiny embedded devices.inetd also offers the ability to inject logic in the handling of connections to less often used services.<br>There are accounts of inetd being used to create jails, enabling single request execution environments.<br>While inetd might feel old, there are clear parallels in more modern software and it is an easily extendable building block.Tom Jones is an Internet Researcher and FreeBSD developer that works on improving the core protocols that drive the Internet.<br>He is acontributor to open standards in the IETF and is enthusiastic about using FreeBSD as a platform to experiment with new networking ideas as they progress towards standardisation.Kernel development is crucial to many companies.<br>If you have a FreeBSD implementation or you’re looking at scoping out work for the future, our team can help you further enable your efforts.FreeBSD can report on the health of the system and perform various routine maintenance tasks using its own built-in mechanism for periodically running scripts.<br>Learn about the periodic system and how to find available scripts, write your own scripts and where and how to apply them.Pot and Nomad are two tools intended to provide cluster provisioning on FreeBSD and replace tools like Docker and Kubernetes, which suffer from lack of sufficient support on FreeBSD.<br>Read how in this article.In his 1999 book In the Beginning… Was the Command Line, Neal Stephenson said the following about Unix: “Windows 95 and MacOS are products, contrived by engineers in the service of specific companies.<br>Unix, by contrast, is not so much a product as it is a painstakingly compiled oral history of the hacker subculture.<br>It is our Gilgamesh epic.”
Read more about how the story of UNIX actually goes.<br> Category: ,        Tags: , , Klara Inc.</p>
