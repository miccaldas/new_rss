[
{"title": "Optimizing GoAWK with a bytecode compiler and virtual machine", "links": "/", "content": "February 2022", "images": []},
{"title": "missing", "links": "/", "content": "Summary: I recently sped up GoAWK by switching from a tree-walking interpreter to a bytecode compiler with a virtual machine interpreter. I discuss why it\u2019s faster and how the new interpreter works.", "images": []},
{"title": "missing", "links": "/cv/", "content": " ", "images": []},
{"title": "missing", "links": "/projects/", "content": " | ", "images": []},
{"title": "missing", "links": "/writings/", "content": " | ", "images": []},
{"title": "missing", "links": "/writings/non-tech/", "content": " | ", "images": []},
{"title": "missing", "links": "mailto:benhoyt@gmail.com", "content": " | ", "images": []},
{"title": "missing", "links": "https://benhoyt.com/", "content": " | ", "images": []},
{"title": "missing", "links": "mailto:benhoyt@gmail.com", "content": "A few years ago I wrote ", "images": []},
{"title": "missing", "links": "#why-are-virtual-machines-faster-than-tree-walking", "content": ", an AWK interpreter written in Go, along with an ", "images": []},
{"title": "missing", "links": "#compiler-and-virtual-machine-details", "content": " describing how it works, how it\u2019s tested, and how I made it faster.", "images": []},
{"title": "missing", "links": "#gos-switch-statement", "content": "GoAWK has been a fun side project, and is ", "images": []},
{"title": "missing", "links": "#other-optimizations-and-a-de-optimization", "content": " in at least one sizeable open source project, the ", "images": []},
{"title": "missing", "links": "#virtual-machine-results", "content": " stream processor. It even landed me my current job at Canonical.", "images": []},
{"title": "missing", "links": "#conclusion", "content": "GoAWK previously used a ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk", "content": ": to execute a code block, it recursively walked the parsed syntax tree. That\u2019s very simple, but not particularly fast. I\u2019ve been wanting to switch to a bytecode compiler and virtual machine interpreter for a while, and I finally got around to it.", "images": []},
{"title": "missing", "links": "/writings/goawk/", "content": "One of my early programming projects was ", "images": []},
{"title": "missing", "links": "https://www.benthos.dev/docs/components/processors/awk", "content": ", a ", "images": []},
{"title": "missing", "links": "https://github.com/Jeffail/benthos", "content": " compiler for DOS. Most Forth compilers, including Third, are simple compilers that use a form of bytecode \u2013 called ", "images": []},
{"title": "missing", "links": "/writings/goawk/#interpreter", "content": " in the Forth world. So I guess you could say I\u2019ve been interested in virtual machines for 25 years \u2026 does that make me a true geek, or just old?", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/third", "content": "It\u2019s not immediately obvious why compiling to virtual instructions and then executing them with a virtual machine is faster than evaluating a syntax tree (\u201ctree-walking\u201d).", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Forth_(programming_language)", "content": "It\u2019s actually ", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Threaded_code", "content": " work up-front: instead of just lexing and parsing into a syntax tree, we now also have a compile step. That said, virtual machine compilers (including GoAWK\u2019s) are usually very simple and non-optimizing, so that step is fast.", "images": []},
{"title": "missing", "links": "http://norvig.com/21-days.html#answers", "content": "One reason it\u2019s faster to execute is this: RAM \u2013 which stands for Random Access Memory \u2013 is not actually ", "images": []},
{"title": "missing", "links": "https://media.handmade-seattle.com/practical-data-oriented-design/", "content": " on modern processors. Memory blocks are loaded into fast CPU caches as needed, so when you have to access a new block, it takes about 10x as long as if it\u2019s in the cache. Peter Norvig\u2019s table of ", "images": []},
{"title": "missing", "links": "https://ziglang.org/", "content": " shows how fetching from level 1 cache takes about 0.5 nanosecond, fetching from level 2 cache 14x that long, and fetching from main memory another 14x!", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/master/internal/compiler/opcodes.go", "content": "Programming with this in mind is called \u201cdata-driven design\u201d. I was reminded of how much impact this makes when watching Andrew Kelley\u2019s excellent talk, ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/16012e2ff77343e6fe93edcb243ad9df08e507b7/internal/compiler/compiler.go#L190", "content": ". Andrew is the creator of the ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/e3a7a275348b7b44653276ebfccda61971461897/interp/vm.go#L30", "content": ", and his talk describes how he significantly sped up the Zig compiler by applying data-driven design techniques. That talk was what pushed me to think about this for GoAWK. But back to why a virtual machine is faster than tree-walking\u2026", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/71e2560da9b5084a175f7a6336c6ecdb5266dc94", "content": "A syntax tree is a bunch of node structures that point to other nodes. They\u2019re scattered around in memory, so to evaluate the child nodes you have to follow pointers and jump around in RAM, possibly evicting whatever\u2019s in the cache already.", "images": []},
{"title": "missing", "links": "https://go-review.googlesource.com/c/go/+/357330/", "content": "Here\u2019s a diagram of the GoAWK syntax tree for the expression ", "images": []},
{"title": "missing", "links": "https://groups.google.com/g/golang-dev/c/CO4flfrYeo4/m/RxmdO1oJDQAJ", "content": ", showing the memory address in hex above each node name:", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/8e04b069b621ff9b9456de57a35ff2fe335cf201", "content": "The ", "images": []},
{"title": "missing", "links": "https://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables", "content": " is only 48 bytes from the ", "images": []},
{"title": "missing", "links": "https://www.nextmovesoftware.com/technology/SwitchOptimization.pdf", "content": ", but the left ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/89aae73fcb0ba6ebbe4981318901a0d696067911", "content": " is 8KB from that, and then its ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/60745c3503ba3d99297816f5c7b5364a08ec47ab", "content": " is almost 120KB away from that. Cache blocks are typically 64 bytes, so each of those probably requires loading an additional cache block from main memory. Not very cache-friendly.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/b05d0d983d4e96ae518c6af3e846fbb1a15040aa", "content": "With a virtual machine interpreter, the instructions are in a nice linear array of opcodes (instruction numbers), which will probably be loaded into a cache block all at once. There\u2019s much less jumping around in RAM. Here\u2019s what the GoAWK virtual machine instructions for that same program look like (you can see this \u201cassembly listing\u201d with the new debug flag, ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/cbe2629f0d8ffa33bc84013a9cb54ac03aac8dcd", "content": "):", "images": []},
{"title": "missing", "links": "https://go-review.googlesource.com/c/go/+/152917", "content": "One of the (relatively few) optimizations GoAWK\u2019s compiler does is shown here: it turns ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/91ddc5b3dcf9c813bdf3378f30d5968abe55b733", "content": " into a single ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/b7ec795b6716aa2159907cce7a54351dc78b0788", "content": " instruction when ", "images": []},
{"title": "missing", "links": "https://github.com/xonixx/gron.awk", "content": " is an integer constant, rather than the two-instruction sequence ", "images": []},
{"title": "missing", "links": "https://accidentallyquadratic.tumblr.com/", "content": " followed by ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/issues/35#issuecomment-1020994304", "content": ". This means most field lookups only go through the opcode decoding loop once instead of twice.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/issues/91", "content": "Another reason the virtual machine approach is faster is because there are fewer function calls, and function calls are relatively slow. When evaluating a syntax tree, the ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/issues/26623", "content": " function recursively calls ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+regexp+label%3APerformance", "content": " again to evaluate child nodes. With a virtual machine, that\u2019s all flattened into a single array of opcodes that we loop over \u2013 no function calls are needed for dispatching opcodes.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/16012e2ff77343e6fe93edcb243ad9df08e507b7", "content": "GoAWK\u2019s virtual machine uses 32-bit opcodes. Initially I was going to use 8-bit opcodes (where the \u201cbyte\u201d in \u201cbytecode\u201d comes from), but 32-bit opcodes were just as fast, and with 32-bit opcodes you avoid the need for variable sized jump offsets: larger AWK scripts may need more than -128 to +127 jump offsets, whereas nobody\u2019s going to need bigger jump offsets than the two billion that 32 bits gives you. 64-bit opcodes are unnecessary big, and they were slightly slower as well.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/master/benchmark.sh", "content": "Here are the first 10 opcodes (there are 85 total \u2013 you can see the full list in ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/master/benchstat.sh", "content": "):", "images": []},
{"title": "missing", "links": "https://github.com/onetrueawk/awk", "content": "As you can see in the ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/releases/tag/v1.15.0", "content": " assembly listing above, I\u2019m using a stack-based virtual machine. This is simpler to implement, because the compiler doesn\u2019t need to figure out how to allocate registers, it just pushes to and pops from the stack. Stack-based virtual machines may be slightly slower, however \u2013 very fast virtual machines like Lua\u2019s are register-based.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/issues", "content": "GoAWK\u2019s compiler is quite simple, with a fairly direct translation from the syntax tree to instructions. I use some specializations for accessing variables of different scopes: for example, fetching a global variable uses the ", "images": []},
{"title": "missing", "links": "https://github.com/sponsors/benhoyt/", "content": " instruction, fetching a local uses ", "images": []},
{"title": "missing", "links": "missing", "content": ". (As you can see, my instruction naming scheme is extremely creative.)", "images": []},
{"title": "missing", "links": "missing", "content": "Here\u2019s the assembly listing for a simple program that sums the numbers from 1 through 10:", "images": []},
{"title": "missing", "links": "missing", "content": "This shows a neat little optimization I copied from Python, whose interpreter added it in Python 3.10 (though I\u2019m sure it\u2019s not a new idea). To compile a ", "images": []},
{"title": "missing", "links": "missing", "content": " or ", "images": []},
{"title": "missing", "links": "missing", "content": " loop, it\u2019d be simplest just to do the test at the top, and then use an unconditional ", "images": []},
{"title": "missing", "links": "missing", "content": " at the bottom of the loop. But that means you\u2019re executing two jump instructions every loop: one at the top and one at the bottom.", "images": []},
{"title": "missing", "links": "missing", "content": "Instead, we compile the condition twice: once inverted before the loop (", "images": []},
{"title": "missing", "links": "missing", "content": ") and once at the bottom of the loop (", "images": []},
{"title": "missing", "links": "missing", "content": "). This is slightly more code overall because the condition is repeated, but the loop itself \u2013 which is what matters \u2013 is one jump instruction shorter.", "images": []},
{"title": "missing", "links": "missing", "content": "We could almost certainly improve the instruction set further, perhaps adding special instructions for integers or strings when we know the type of the operation ahead of time. That adds complexity, however, and for now I\u2019m going to keep it simple.", "images": []},
{"title": "missing", "links": "missing", "content": "The one other optimization the GoAWK compiler does is for assignments. Assignments in AWK are expressions, so by default you\u2019d push their value on the stack \u2026 only to discard it right away in most cases. And you rarely use the value of an assignment expression.", "images": []},
{"title": "missing", "links": "missing", "content": "Here\u2019s the assembly for an optimized assignment expression:", "images": []},
{"title": "missing", "links": "missing", "content": "And here\u2019s what it would look like if we didn\u2019t have that optimization:", "images": []},
{"title": "missing", "links": "missing", "content": "Below is the ", "images": []},
{"title": "missing", "links": "missing", "content": ", showing the special case used for this optimization. I also include how we compile ", "images": []},
{"title": "missing", "links": "missing", "content": " statements, to show something quite different. Note how the compiler makes heavy use of Go\u2019s type switch:", "images": []},
{"title": "missing", "links": "missing", "content": "The virtual machine ", "images": []},
{"title": "missing", "links": "missing", "content": " function is a single ", "images": []},
{"title": "missing", "links": "missing", "content": " loop with a big ", "images": []},
{"title": "missing", "links": "missing", "content": " statement \u2013 one ", "images": []},
{"title": "missing", "links": "missing", "content": " for each opcode. Here\u2019s a snippet showing the instruction fetching and the code to handle a few of the opcodes:", "images": []},
{"title": "missing", "links": "missing", "content": "As shown above, the virtual machine is implemented as a big ", "images": []},
{"title": "missing", "links": "missing", "content": " statement with one ", "images": []},
{"title": "missing", "links": "missing", "content": " per opcode (around 80 cases). Go\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " statement is currently implemented as a binary search through the \u201ccase space\u201d. You can think of it as compiling to something like this \u2013 for brevity, only a few branches of the tree are shown in full:", "images": []},
{"title": "missing", "links": "missing", "content": "As you can see, you need to do O(log", "images": []},
{"title": "missing", "links": "missing", "content": " N) comparisons and jumps to get down to the case you\u2019re interested in. For 80 opcodes, that\u2019s 6 or 7 branches to decode every instruction.", "images": []},
{"title": "missing", "links": "missing", "content": "As the number of instructions grows, the number of branches grows too (though thankfully that growth is logarithmic, not linear). When I first coded a proof-of-concept virtual machine for GoAWK and just implemented the 7 or 8 instructions I needed for the demo, it gave a huge performance boost, almost 40% faster, because the ", "images": []},
{"title": "missing", "links": "missing", "content": " only had a few cases. But now that I have all the opcodes in place, it\u2019s \u201conly\u201d 18% faster.", "images": []},
{"title": "missing", "links": "missing", "content": "It was actually slower than that when I had around 100 opcodes. I removed some specializations that I had thought would speed things up, but with fewer opcodes it meant one less binary search branch and was actually ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "It\u2019d be great if there were a way to get constant time instruction dispatch, no matter how many instructions we have. Why can\u2019t Go implement ", "images": []},
{"title": "missing", "links": "missing", "content": " as a table of jump addresses: look up the code address in a table and jump directly to it? It turns out Keith Randall on the Go team is ", "images": []},
{"title": "missing", "links": "missing", "content": ", so we may get it in Go 1.19.", "images": []},
{"title": "missing", "links": "missing", "content": "I tried Keith\u2019s branch (which only works with ", "images": []},
{"title": "missing", "links": "missing", "content": " types at the moment) on GoAWK, and it ", "images": []},
{"title": "missing", "links": "missing", "content": " of a simple microbenchmark by 10%. So I\u2019m definitely looking forward to the Go compiler learning about \u201cjump tables\u201d.", "images": []},
{"title": "missing", "links": "missing", "content": "Could we do this optimization ourself? What about an array of functions? I tried that, turning the dispatch loop into the following:", "images": []},
{"title": "missing", "links": "missing", "content": "This only gave me a 1-2% speed increase on GoAWK\u2019s microbenchmarks (", "images": []},
{"title": "missing", "links": "missing", "content": "). In the end I decided I\u2019d rather stick with the simpler ", "images": []},
{"title": "missing", "links": "missing", "content": " code and find other ways to improve the speed. And when the Go compiler supports jump tables for ", "images": []},
{"title": "missing", "links": "missing", "content": ", I\u2019ll get a 10% improvement by doing nothing!", "images": []},
{"title": "missing", "links": "missing", "content": "The ", "images": []},
{"title": "missing", "links": "missing", "content": " compiler has a non-standard feature called \u201ccomputed goto\u201d, which allows you to write something like ", "images": []},
{"title": "missing", "links": "missing", "content": " at the end of each opcode\u2019s code to jump directly to the code for the next opcode. Eli Bendersky has written an ", "images": []},
{"title": "missing", "links": "missing", "content": ", so I won\u2019t dwell on it further here. Most virtual machines written in C use this technique, including CPython and many others. Unfortunately Go doesn\u2019t have computed goto, but again, when ", "images": []},
{"title": "missing", "links": "missing", "content": " is compiled to a jump table, that will get us half way there.", "images": []},
{"title": "missing", "links": "missing", "content": "If you\u2019re interested in reading something a bit more academic about how compilers can optimize ", "images": []},
{"title": "missing", "links": "missing", "content": ", read the paper ", "images": []},
{"title": "missing", "links": "missing", "content": " by Roger Sayle, which was presented at the 2008 GCC Developers\u2019 Summit.", "images": []},
{"title": "missing", "links": "missing", "content": "Apart from converting from tree-walking to a virtual machine, I\u2019ve recently added a few other optimizations:", "images": []},
{"title": "missing", "links": "missing", "content": "One problematic ", "images": []},
{"title": "missing", "links": "missing", "content": " I did was to change GoAWK\u2019s string functions, such as ", "images": []},
{"title": "missing", "links": "missing", "content": " and ", "images": []},
{"title": "missing", "links": "missing", "content": ", to use Unicode character indexes rather than byte indexes. I knew this was going to change these operations from O(1) to O(N) in the length of the string, but I figured it wouldn\u2019t matter that much because \u201cN is usually small\u201d.", "images": []},
{"title": "missing", "links": "missing", "content": "That assumption turned out not to be the case: Volodymyr Gubarkov\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " script went from processing a large JSON file in 1 second to over 8 minutes \u2013 ", "images": []},
{"title": "missing", "links": "missing", "content": ". This was untenable, so I decided to revert that fix for now, and figure out an O(1) way to address this in future. Arnold Robbins, long-time maintainer of Gawk, ", "images": []},
{"title": "missing", "links": "missing", "content": " on how Gawk does a lot of work to make string handling efficient.", "images": []},
{"title": "missing", "links": "missing", "content": "I hope to optimize GoAWK further in the future, and have opened an ", "images": []},
{"title": "missing", "links": "missing", "content": " to track future performance work. Here are some of the ideas:", "images": []},
{"title": "missing", "links": "missing", "content": " Here are a few things I\u2019m considering to speed up the virtual machine:", "images": []},
{"title": "missing", "links": "missing", "content": " is also unnecessarily expensive due to excess allocations and copying when you\u2019re concatenating more than two strings. Currently a multi-concatenation expression like ", "images": []},
{"title": "missing", "links": "missing", "content": " is compiled to two binary ", "images": []},
{"title": "missing", "links": "missing", "content": " instructions:", "images": []},
{"title": "missing", "links": "missing", "content": "It\u2019d be more efficient for the compiler to detect this and output a new ", "images": []},
{"title": "missing", "links": "missing", "content": " instruction, for example:", "images": []},
{"title": "missing", "links": "missing", "content": "This is one fewer instruction, but more importantly, it would avoid allocating a temporary string only to have to allocate a new one and copy the bytes over. Concatenating more than two values is quite common in AWK, and this optimization would get better the more values you\u2019re concatenating.", "images": []},
{"title": "missing", "links": "missing", "content": " would be great to speed up. GoAWK currently uses Go\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " package, but unfortunately it\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": ". This makes AWK scripts that use regular expressions heavily about half the speed of Gawk and almost a quarter the speed of Mawk.", "images": []},
{"title": "missing", "links": "missing", "content": "There are two ways to improve this:", "images": []},
{"title": "missing", "links": "missing", "content": "So how much faster ", "images": []},
{"title": "missing", "links": "missing", "content": " the virtual machine interpreter? The microbenchmarks \u2013 which admittedly are mostly not the kind of scripts you\u2019d write in AWK \u2013 got about 18% faster overall. These are elapsed times, so smaller is better (you can see the ", "images": []},
{"title": "missing", "links": "missing", "content": " or measure them yourself using ", "images": []},
{"title": "missing", "links": "missing", "content": " followed by ", "images": []},
{"title": "missing", "links": "missing", "content": " to show these deltas):", "images": []},
{"title": "missing", "links": "missing", "content": "Increment, decrement, and augmented assignment are so much faster because the virtual machine has dedicated opcodes for them. Variable access has improved considerably too, as have ", "images": []},
{"title": "missing", "links": "missing", "content": " loops, ", "images": []},
{"title": "missing", "links": "missing", "content": " statements, binary operators, and many other benchmarks.", "images": []},
{"title": "missing", "links": "missing", "content": "My more \u201creal world\u201d benchmark suite \u2013 most of which I pulled from the ", "images": []},
{"title": "missing", "links": "missing", "content": " \u2013 got 13% faster overall. In this table, ", "images": []},
{"title": "missing", "links": "missing", "content": " is the new virtual machine interpreter and ", "images": []},
{"title": "missing", "links": "missing", "content": " is the old tree-walking one. Somewhat unintuitively, the numbers here are the number of times faster it is than the original ", "images": []},
{"title": "missing", "links": "missing", "content": ", so ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "I definitely like the performance improvements I got. They weren\u2019t quite as much as I was hoping for, but the fact that GoAWK is faster than Gawk for many CPU-bound operations now is pretty cool. It\u2019s still always slower than the performance-fiend Mawk. And for the stuff that AWK is normally used for \u2013 string processing and regular expressions \u2013 GoAWK still has a lot of room for improvement.", "images": []},
{"title": "missing", "links": "missing", "content": "To be honest, I\u2019m not entirely sure it was worth the additional 2500 lines of code (for a project that\u2019s only 15,000 lines of code, including tests). If I had an engineering manager overseeing this, I would have expected pushback (\u201cis this going to help us with real-world workloads?\u201d). However, GoAWK was and remains a passion project \u2013 I had fun making and sharing this, and that\u2019s enough for me.", "images": []},
{"title": "missing", "links": "missing", "content": "I\u2019ve merged the compiler and virtual machine and released them in ", "images": []},
{"title": "missing", "links": "missing", "content": ". The Go API and ", "images": []},
{"title": "missing", "links": "missing", "content": " command should be 100% backwards compatible. It\u2019s been well-tested against my interpreter tests as well as the tests from the original AWK and the relevant ones from Gawk, but file an ", "images": []},
{"title": "missing", "links": "missing", "content": " if you find something amiss.", "images": []},
{"title": "missing", "links": "missing", "content": "I hope you\u2019ve enjoyed or learned from this write-up. Please don\u2019t hesitate to contact me with your feedback or ideas.", "images": []},
{"title": "missing", "links": "missing", "content": "I\u2019d love it if you ", "images": []},
{"title": "missing", "links": "missing", "content": " \u2013 it will motivate me to work on my open source projects and write more good content. Thanks!", "images": []}
][
{"title": "Optimizing GoAWK with a bytecode compiler and virtual machine", "links": "/", "content": "February 2022", "images": []},
{"title": "missing", "links": "/", "content": "Summary: I recently sped up GoAWK by switching from a tree-walking interpreter to a bytecode compiler with a virtual machine interpreter. I discuss why it\u2019s faster and how the new interpreter works.", "images": []},
{"title": "missing", "links": "/cv/", "content": " ", "images": []},
{"title": "missing", "links": "/projects/", "content": " | ", "images": []},
{"title": "missing", "links": "/writings/", "content": " | ", "images": []},
{"title": "missing", "links": "/writings/non-tech/", "content": " | ", "images": []},
{"title": "missing", "links": "mailto:benhoyt@gmail.com", "content": " | ", "images": []},
{"title": "missing", "links": "https://benhoyt.com/", "content": " | ", "images": []},
{"title": "missing", "links": "mailto:benhoyt@gmail.com", "content": "A few years ago I wrote ", "images": []},
{"title": "missing", "links": "#why-are-virtual-machines-faster-than-tree-walking", "content": ", an AWK interpreter written in Go, along with an ", "images": []},
{"title": "missing", "links": "#compiler-and-virtual-machine-details", "content": " describing how it works, how it\u2019s tested, and how I made it faster.", "images": []},
{"title": "missing", "links": "#gos-switch-statement", "content": "GoAWK has been a fun side project, and is ", "images": []},
{"title": "missing", "links": "#other-optimizations-and-a-de-optimization", "content": " in at least one sizeable open source project, the ", "images": []},
{"title": "missing", "links": "#virtual-machine-results", "content": " stream processor. It even landed me my current job at Canonical.", "images": []},
{"title": "missing", "links": "#conclusion", "content": "GoAWK previously used a ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk", "content": ": to execute a code block, it recursively walked the parsed syntax tree. That\u2019s very simple, but not particularly fast. I\u2019ve been wanting to switch to a bytecode compiler and virtual machine interpreter for a while, and I finally got around to it.", "images": []},
{"title": "missing", "links": "/writings/goawk/", "content": "One of my early programming projects was ", "images": []},
{"title": "missing", "links": "https://www.benthos.dev/docs/components/processors/awk", "content": ", a ", "images": []},
{"title": "missing", "links": "https://github.com/Jeffail/benthos", "content": " compiler for DOS. Most Forth compilers, including Third, are simple compilers that use a form of bytecode \u2013 called ", "images": []},
{"title": "missing", "links": "/writings/goawk/#interpreter", "content": " in the Forth world. So I guess you could say I\u2019ve been interested in virtual machines for 25 years \u2026 does that make me a true geek, or just old?", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/third", "content": "It\u2019s not immediately obvious why compiling to virtual instructions and then executing them with a virtual machine is faster than evaluating a syntax tree (\u201ctree-walking\u201d).", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Forth_(programming_language)", "content": "It\u2019s actually ", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Threaded_code", "content": " work up-front: instead of just lexing and parsing into a syntax tree, we now also have a compile step. That said, virtual machine compilers (including GoAWK\u2019s) are usually very simple and non-optimizing, so that step is fast.", "images": []},
{"title": "missing", "links": "http://norvig.com/21-days.html#answers", "content": "One reason it\u2019s faster to execute is this: RAM \u2013 which stands for Random Access Memory \u2013 is not actually ", "images": []},
{"title": "missing", "links": "https://media.handmade-seattle.com/practical-data-oriented-design/", "content": " on modern processors. Memory blocks are loaded into fast CPU caches as needed, so when you have to access a new block, it takes about 10x as long as if it\u2019s in the cache. Peter Norvig\u2019s table of ", "images": []},
{"title": "missing", "links": "https://ziglang.org/", "content": " shows how fetching from level 1 cache takes about 0.5 nanosecond, fetching from level 2 cache 14x that long, and fetching from main memory another 14x!", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/master/internal/compiler/opcodes.go", "content": "Programming with this in mind is called \u201cdata-driven design\u201d. I was reminded of how much impact this makes when watching Andrew Kelley\u2019s excellent talk, ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/16012e2ff77343e6fe93edcb243ad9df08e507b7/internal/compiler/compiler.go#L190", "content": ". Andrew is the creator of the ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/e3a7a275348b7b44653276ebfccda61971461897/interp/vm.go#L30", "content": ", and his talk describes how he significantly sped up the Zig compiler by applying data-driven design techniques. That talk was what pushed me to think about this for GoAWK. But back to why a virtual machine is faster than tree-walking\u2026", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/71e2560da9b5084a175f7a6336c6ecdb5266dc94", "content": "A syntax tree is a bunch of node structures that point to other nodes. They\u2019re scattered around in memory, so to evaluate the child nodes you have to follow pointers and jump around in RAM, possibly evicting whatever\u2019s in the cache already.", "images": []},
{"title": "missing", "links": "https://go-review.googlesource.com/c/go/+/357330/", "content": "Here\u2019s a diagram of the GoAWK syntax tree for the expression ", "images": []},
{"title": "missing", "links": "https://groups.google.com/g/golang-dev/c/CO4flfrYeo4/m/RxmdO1oJDQAJ", "content": ", showing the memory address in hex above each node name:", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/8e04b069b621ff9b9456de57a35ff2fe335cf201", "content": "The ", "images": []},
{"title": "missing", "links": "https://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables", "content": " is only 48 bytes from the ", "images": []},
{"title": "missing", "links": "https://www.nextmovesoftware.com/technology/SwitchOptimization.pdf", "content": ", but the left ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/89aae73fcb0ba6ebbe4981318901a0d696067911", "content": " is 8KB from that, and then its ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/60745c3503ba3d99297816f5c7b5364a08ec47ab", "content": " is almost 120KB away from that. Cache blocks are typically 64 bytes, so each of those probably requires loading an additional cache block from main memory. Not very cache-friendly.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/b05d0d983d4e96ae518c6af3e846fbb1a15040aa", "content": "With a virtual machine interpreter, the instructions are in a nice linear array of opcodes (instruction numbers), which will probably be loaded into a cache block all at once. There\u2019s much less jumping around in RAM. Here\u2019s what the GoAWK virtual machine instructions for that same program look like (you can see this \u201cassembly listing\u201d with the new debug flag, ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/cbe2629f0d8ffa33bc84013a9cb54ac03aac8dcd", "content": "):", "images": []},
{"title": "missing", "links": "https://go-review.googlesource.com/c/go/+/152917", "content": "One of the (relatively few) optimizations GoAWK\u2019s compiler does is shown here: it turns ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/91ddc5b3dcf9c813bdf3378f30d5968abe55b733", "content": " into a single ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/b7ec795b6716aa2159907cce7a54351dc78b0788", "content": " instruction when ", "images": []},
{"title": "missing", "links": "https://github.com/xonixx/gron.awk", "content": " is an integer constant, rather than the two-instruction sequence ", "images": []},
{"title": "missing", "links": "https://accidentallyquadratic.tumblr.com/", "content": " followed by ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/issues/35#issuecomment-1020994304", "content": ". This means most field lookups only go through the opcode decoding loop once instead of twice.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/issues/91", "content": "Another reason the virtual machine approach is faster is because there are fewer function calls, and function calls are relatively slow. When evaluating a syntax tree, the ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/issues/26623", "content": " function recursively calls ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+regexp+label%3APerformance", "content": " again to evaluate child nodes. With a virtual machine, that\u2019s all flattened into a single array of opcodes that we loop over \u2013 no function calls are needed for dispatching opcodes.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/commit/16012e2ff77343e6fe93edcb243ad9df08e507b7", "content": "GoAWK\u2019s virtual machine uses 32-bit opcodes. Initially I was going to use 8-bit opcodes (where the \u201cbyte\u201d in \u201cbytecode\u201d comes from), but 32-bit opcodes were just as fast, and with 32-bit opcodes you avoid the need for variable sized jump offsets: larger AWK scripts may need more than -128 to +127 jump offsets, whereas nobody\u2019s going to need bigger jump offsets than the two billion that 32 bits gives you. 64-bit opcodes are unnecessary big, and they were slightly slower as well.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/master/benchmark.sh", "content": "Here are the first 10 opcodes (there are 85 total \u2013 you can see the full list in ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/blob/master/benchstat.sh", "content": "):", "images": []},
{"title": "missing", "links": "https://github.com/onetrueawk/awk", "content": "As you can see in the ", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/releases/tag/v1.15.0", "content": " assembly listing above, I\u2019m using a stack-based virtual machine. This is simpler to implement, because the compiler doesn\u2019t need to figure out how to allocate registers, it just pushes to and pops from the stack. Stack-based virtual machines may be slightly slower, however \u2013 very fast virtual machines like Lua\u2019s are register-based.", "images": []},
{"title": "missing", "links": "https://github.com/benhoyt/goawk/issues", "content": "GoAWK\u2019s compiler is quite simple, with a fairly direct translation from the syntax tree to instructions. I use some specializations for accessing variables of different scopes: for example, fetching a global variable uses the ", "images": []},
{"title": "missing", "links": "https://github.com/sponsors/benhoyt/", "content": " instruction, fetching a local uses ", "images": []},
{"title": "missing", "links": "missing", "content": ". (As you can see, my instruction naming scheme is extremely creative.)", "images": []},
{"title": "missing", "links": "missing", "content": "Here\u2019s the assembly listing for a simple program that sums the numbers from 1 through 10:", "images": []},
{"title": "missing", "links": "missing", "content": "This shows a neat little optimization I copied from Python, whose interpreter added it in Python 3.10 (though I\u2019m sure it\u2019s not a new idea). To compile a ", "images": []},
{"title": "missing", "links": "missing", "content": " or ", "images": []},
{"title": "missing", "links": "missing", "content": " loop, it\u2019d be simplest just to do the test at the top, and then use an unconditional ", "images": []},
{"title": "missing", "links": "missing", "content": " at the bottom of the loop. But that means you\u2019re executing two jump instructions every loop: one at the top and one at the bottom.", "images": []},
{"title": "missing", "links": "missing", "content": "Instead, we compile the condition twice: once inverted before the loop (", "images": []},
{"title": "missing", "links": "missing", "content": ") and once at the bottom of the loop (", "images": []},
{"title": "missing", "links": "missing", "content": "). This is slightly more code overall because the condition is repeated, but the loop itself \u2013 which is what matters \u2013 is one jump instruction shorter.", "images": []},
{"title": "missing", "links": "missing", "content": "We could almost certainly improve the instruction set further, perhaps adding special instructions for integers or strings when we know the type of the operation ahead of time. That adds complexity, however, and for now I\u2019m going to keep it simple.", "images": []},
{"title": "missing", "links": "missing", "content": "The one other optimization the GoAWK compiler does is for assignments. Assignments in AWK are expressions, so by default you\u2019d push their value on the stack \u2026 only to discard it right away in most cases. And you rarely use the value of an assignment expression.", "images": []},
{"title": "missing", "links": "missing", "content": "Here\u2019s the assembly for an optimized assignment expression:", "images": []},
{"title": "missing", "links": "missing", "content": "And here\u2019s what it would look like if we didn\u2019t have that optimization:", "images": []},
{"title": "missing", "links": "missing", "content": "Below is the ", "images": []},
{"title": "missing", "links": "missing", "content": ", showing the special case used for this optimization. I also include how we compile ", "images": []},
{"title": "missing", "links": "missing", "content": " statements, to show something quite different. Note how the compiler makes heavy use of Go\u2019s type switch:", "images": []},
{"title": "missing", "links": "missing", "content": "The virtual machine ", "images": []},
{"title": "missing", "links": "missing", "content": " function is a single ", "images": []},
{"title": "missing", "links": "missing", "content": " loop with a big ", "images": []},
{"title": "missing", "links": "missing", "content": " statement \u2013 one ", "images": []},
{"title": "missing", "links": "missing", "content": " for each opcode. Here\u2019s a snippet showing the instruction fetching and the code to handle a few of the opcodes:", "images": []},
{"title": "missing", "links": "missing", "content": "As shown above, the virtual machine is implemented as a big ", "images": []},
{"title": "missing", "links": "missing", "content": " statement with one ", "images": []},
{"title": "missing", "links": "missing", "content": " per opcode (around 80 cases). Go\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " statement is currently implemented as a binary search through the \u201ccase space\u201d. You can think of it as compiling to something like this \u2013 for brevity, only a few branches of the tree are shown in full:", "images": []},
{"title": "missing", "links": "missing", "content": "As you can see, you need to do O(log", "images": []},
{"title": "missing", "links": "missing", "content": " N) comparisons and jumps to get down to the case you\u2019re interested in. For 80 opcodes, that\u2019s 6 or 7 branches to decode every instruction.", "images": []},
{"title": "missing", "links": "missing", "content": "As the number of instructions grows, the number of branches grows too (though thankfully that growth is logarithmic, not linear). When I first coded a proof-of-concept virtual machine for GoAWK and just implemented the 7 or 8 instructions I needed for the demo, it gave a huge performance boost, almost 40% faster, because the ", "images": []},
{"title": "missing", "links": "missing", "content": " only had a few cases. But now that I have all the opcodes in place, it\u2019s \u201conly\u201d 18% faster.", "images": []},
{"title": "missing", "links": "missing", "content": "It was actually slower than that when I had around 100 opcodes. I removed some specializations that I had thought would speed things up, but with fewer opcodes it meant one less binary search branch and was actually ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "It\u2019d be great if there were a way to get constant time instruction dispatch, no matter how many instructions we have. Why can\u2019t Go implement ", "images": []},
{"title": "missing", "links": "missing", "content": " as a table of jump addresses: look up the code address in a table and jump directly to it? It turns out Keith Randall on the Go team is ", "images": []},
{"title": "missing", "links": "missing", "content": ", so we may get it in Go 1.19.", "images": []},
{"title": "missing", "links": "missing", "content": "I tried Keith\u2019s branch (which only works with ", "images": []},
{"title": "missing", "links": "missing", "content": " types at the moment) on GoAWK, and it ", "images": []},
{"title": "missing", "links": "missing", "content": " of a simple microbenchmark by 10%. So I\u2019m definitely looking forward to the Go compiler learning about \u201cjump tables\u201d.", "images": []},
{"title": "missing", "links": "missing", "content": "Could we do this optimization ourself? What about an array of functions? I tried that, turning the dispatch loop into the following:", "images": []},
{"title": "missing", "links": "missing", "content": "This only gave me a 1-2% speed increase on GoAWK\u2019s microbenchmarks (", "images": []},
{"title": "missing", "links": "missing", "content": "). In the end I decided I\u2019d rather stick with the simpler ", "images": []},
{"title": "missing", "links": "missing", "content": " code and find other ways to improve the speed. And when the Go compiler supports jump tables for ", "images": []},
{"title": "missing", "links": "missing", "content": ", I\u2019ll get a 10% improvement by doing nothing!", "images": []},
{"title": "missing", "links": "missing", "content": "The ", "images": []},
{"title": "missing", "links": "missing", "content": " compiler has a non-standard feature called \u201ccomputed goto\u201d, which allows you to write something like ", "images": []},
{"title": "missing", "links": "missing", "content": " at the end of each opcode\u2019s code to jump directly to the code for the next opcode. Eli Bendersky has written an ", "images": []},
{"title": "missing", "links": "missing", "content": ", so I won\u2019t dwell on it further here. Most virtual machines written in C use this technique, including CPython and many others. Unfortunately Go doesn\u2019t have computed goto, but again, when ", "images": []},
{"title": "missing", "links": "missing", "content": " is compiled to a jump table, that will get us half way there.", "images": []},
{"title": "missing", "links": "missing", "content": "If you\u2019re interested in reading something a bit more academic about how compilers can optimize ", "images": []},
{"title": "missing", "links": "missing", "content": ", read the paper ", "images": []},
{"title": "missing", "links": "missing", "content": " by Roger Sayle, which was presented at the 2008 GCC Developers\u2019 Summit.", "images": []},
{"title": "missing", "links": "missing", "content": "Apart from converting from tree-walking to a virtual machine, I\u2019ve recently added a few other optimizations:", "images": []},
{"title": "missing", "links": "missing", "content": "One problematic ", "images": []},
{"title": "missing", "links": "missing", "content": " I did was to change GoAWK\u2019s string functions, such as ", "images": []},
{"title": "missing", "links": "missing", "content": " and ", "images": []},
{"title": "missing", "links": "missing", "content": ", to use Unicode character indexes rather than byte indexes. I knew this was going to change these operations from O(1) to O(N) in the length of the string, but I figured it wouldn\u2019t matter that much because \u201cN is usually small\u201d.", "images": []},
{"title": "missing", "links": "missing", "content": "That assumption turned out not to be the case: Volodymyr Gubarkov\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " script went from processing a large JSON file in 1 second to over 8 minutes \u2013 ", "images": []},
{"title": "missing", "links": "missing", "content": ". This was untenable, so I decided to revert that fix for now, and figure out an O(1) way to address this in future. Arnold Robbins, long-time maintainer of Gawk, ", "images": []},
{"title": "missing", "links": "missing", "content": " on how Gawk does a lot of work to make string handling efficient.", "images": []},
{"title": "missing", "links": "missing", "content": "I hope to optimize GoAWK further in the future, and have opened an ", "images": []},
{"title": "missing", "links": "missing", "content": " to track future performance work. Here are some of the ideas:", "images": []},
{"title": "missing", "links": "missing", "content": " Here are a few things I\u2019m considering to speed up the virtual machine:", "images": []},
{"title": "missing", "links": "missing", "content": " is also unnecessarily expensive due to excess allocations and copying when you\u2019re concatenating more than two strings. Currently a multi-concatenation expression like ", "images": []},
{"title": "missing", "links": "missing", "content": " is compiled to two binary ", "images": []},
{"title": "missing", "links": "missing", "content": " instructions:", "images": []},
{"title": "missing", "links": "missing", "content": "It\u2019d be more efficient for the compiler to detect this and output a new ", "images": []},
{"title": "missing", "links": "missing", "content": " instruction, for example:", "images": []},
{"title": "missing", "links": "missing", "content": "This is one fewer instruction, but more importantly, it would avoid allocating a temporary string only to have to allocate a new one and copy the bytes over. Concatenating more than two values is quite common in AWK, and this optimization would get better the more values you\u2019re concatenating.", "images": []},
{"title": "missing", "links": "missing", "content": " would be great to speed up. GoAWK currently uses Go\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " package, but unfortunately it\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": ". This makes AWK scripts that use regular expressions heavily about half the speed of Gawk and almost a quarter the speed of Mawk.", "images": []},
{"title": "missing", "links": "missing", "content": "There are two ways to improve this:", "images": []},
{"title": "missing", "links": "missing", "content": "So how much faster ", "images": []},
{"title": "missing", "links": "missing", "content": " the virtual machine interpreter? The microbenchmarks \u2013 which admittedly are mostly not the kind of scripts you\u2019d write in AWK \u2013 got about 18% faster overall. These are elapsed times, so smaller is better (you can see the ", "images": []},
{"title": "missing", "links": "missing", "content": " or measure them yourself using ", "images": []},
{"title": "missing", "links": "missing", "content": " followed by ", "images": []},
{"title": "missing", "links": "missing", "content": " to show these deltas):", "images": []},
{"title": "missing", "links": "missing", "content": "Increment, decrement, and augmented assignment are so much faster because the virtual machine has dedicated opcodes for them. Variable access has improved considerably too, as have ", "images": []},
{"title": "missing", "links": "missing", "content": " loops, ", "images": []},
{"title": "missing", "links": "missing", "content": " statements, binary operators, and many other benchmarks.", "images": []},
{"title": "missing", "links": "missing", "content": "My more \u201creal world\u201d benchmark suite \u2013 most of which I pulled from the ", "images": []},
{"title": "missing", "links": "missing", "content": " \u2013 got 13% faster overall. In this table, ", "images": []},
{"title": "missing", "links": "missing", "content": " is the new virtual machine interpreter and ", "images": []},
{"title": "missing", "links": "missing", "content": " is the old tree-walking one. Somewhat unintuitively, the numbers here are the number of times faster it is than the original ", "images": []},
{"title": "missing", "links": "missing", "content": ", so ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "I definitely like the performance improvements I got. They weren\u2019t quite as much as I was hoping for, but the fact that GoAWK is faster than Gawk for many CPU-bound operations now is pretty cool. It\u2019s still always slower than the performance-fiend Mawk. And for the stuff that AWK is normally used for \u2013 string processing and regular expressions \u2013 GoAWK still has a lot of room for improvement.", "images": []},
{"title": "missing", "links": "missing", "content": "To be honest, I\u2019m not entirely sure it was worth the additional 2500 lines of code (for a project that\u2019s only 15,000 lines of code, including tests). If I had an engineering manager overseeing this, I would have expected pushback (\u201cis this going to help us with real-world workloads?\u201d). However, GoAWK was and remains a passion project \u2013 I had fun making and sharing this, and that\u2019s enough for me.", "images": []},
{"title": "missing", "links": "missing", "content": "I\u2019ve merged the compiler and virtual machine and released them in ", "images": []},
{"title": "missing", "links": "missing", "content": ". The Go API and ", "images": []},
{"title": "missing", "links": "missing", "content": " command should be 100% backwards compatible. It\u2019s been well-tested against my interpreter tests as well as the tests from the original AWK and the relevant ones from Gawk, but file an ", "images": []},
{"title": "missing", "links": "missing", "content": " if you find something amiss.", "images": []},
{"title": "missing", "links": "missing", "content": "I hope you\u2019ve enjoyed or learned from this write-up. Please don\u2019t hesitate to contact me with your feedback or ideas.", "images": []},
{"title": "missing", "links": "missing", "content": "I\u2019d love it if you ", "images": []},
{"title": "missing", "links": "missing", "content": " \u2013 it will motivate me to work on my open source projects and write more good content. Thanks!", "images": []}
]