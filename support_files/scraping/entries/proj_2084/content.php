<p>Three months ago, I was looking into building coverage for eBPF programs.That’s how  was born.I did not want to reinvent the wheel, so I was looking into the existing coverage instrumentation features of LLVM.Among the different options LLVM provides,  suddenly appeared very appealing to me.It’s the most precise type of code coverage.<br>In my opinion, the only one that gives its user a damn clue on what code region of the program is executing.<br>It also helps understand why a particular code branch gets executed.Using it is pretty straightforward.<br>All resolve to the following steps:You now have a beautifully fine-grained coverage report for your C/C++ code.But what caught my eye was feeling that this kind of coverage was not using debug info (like  does) at all, but it was using profiling data, coming directly from the darkest parts of LLVM.My curiosity took me to some extraordinary places in the LLVM codebase…I wanted to understand what the  was causing.Also, I wanted to know how I got a binary file () without my code writing anything to the disk.And what it contained..<br>It contains the globals that the  instruments into your code.But we probably need to move one step at a time to learn something new.So, this is the dummy C code -  - that I used to walk myself through this study.I compiled it to textual LLVM IR:In a matter of milliseconds, I was able to look at its intermediate representation:It stands out from what we see that it contains:Also, all these variables have ELF sections.The  variables end up into the  section.
The  variables end up into the  section.
The  variable ends up into the  section.But what  variables are?The section names helped me here: they are the  used by LLVM for instrumenting our code for !Scrolling down into the LLVM IR, we see they’re getting incremented (, ,  instructions sequence) at the correct spots:We now know why the  array has size 3 (see ): LLVM instrumented one counter for the  function’s entry, one for the  block, while the last one regards the  block.We also know that we have a total of 5 counters, given the  and  have both size 1.Verifying this is just a matter of obtaining our program binary…And playing with :The output here helps us confirm that we have 5 total counters of 8 bytes each, starting at address  and ending at .In fact, $c138 - c110 = 28$, which means 40 bytes in decimal base (ie., $8 * 5$).What about the  variables instead?At the moment, all you need to know is that those are structs containing data about the function they refer to and the instrumented counters for it.I hope the following image clarifies the relationship.<br>Anyways, we’ll dig deeper into the  variables .At this point, I still didn’t know  the  file got created every time I executed my binary.I came back to the LLVM source code.<br>It’s incredible the superpowers that reading the source gives you…I found .Long story short: the code in this LLVM source file implements the , which means it is responsible for gathering all the data from the variables (counters, data, etc.) we’ve seen and flushing them out in the  file.While looking at it, I suddenly noticed the  function.It gets invoked by the profiling runtime initialization hook to get the filename of the profraw to create.<br>Either from an environment variable () or using the default one ().<br>Finally, it calls the C library function .<br>Which will cause the  function to be invoked when the program terminates.Thus, I also noticed the  function.The main thing this function does is to invoke .<br>Which, in turn, calls  .It’s again time to verify with .Our ELF got flooded by  functions.Seeing all those symbols in the ELF made me 100% sure this is how LLVM makes our binary open the  file as soon it executes.<br>In this way, it also makes our program automatically dump the profile data when it terminates.Coming back to the  function implementation (in the  source file), we instead discover  it dumps into .<br>It’s while doing so that we understand what a profraw file contains.Such a function:All these moving parts are written using the  data structure.So, we can finally assert what a profraw binary file is composed by:The  macro at  defines the parts composing the header of the profraw file.<br>Which are:With the following table I tried to summarize the header’s content:But probably an image is worth a thousand words.This is the  file after executing :We can see that its header is composed of:Exactly the way we were now expecting it.Focusing on the data part, I’ve highlighted with (orange) rectangles the 3  global variables.Each of the  contains 6 parts:After the data parte comes the counters part.It just is a serialization of what the variables in the  ELF section contains.In fact, in this screenshot you can see underlined (with waves, in shades of cyan/blue):Finally, the  variable populates the last part of the profraw file.Here (in grey) you can see its content, padded with a  byte (the one circled) at the end to align the profraw file size to be multiple of 8.It’s time to use the  file now:Isn’t it cool?There’s more you can do with profraw files and the LLVM toolchain, indeed.<br>But showing that was not the goal of this post.I hope you now have a better understanding of what profraw files are.Three months ago, I was looking into building coverage for eBPF programs.That’s how  was born.I did not want to reinvent the wheel, so I was looking into the existing coverage instrumentation features of LLVM.Among the different options LLVM provides,  suddenly appeared very appealing to me.It’s the most precise type of code coverage.<br>In my opinion, the only one that gives its user a damn clue on what code region of the program is executing.<br>It also helps understand why a particular code branch gets executed.Using it is pretty straightforward.<br>All resolve to the following steps:You now have a beautifully fine-grained coverage report for your C/C++ code.But what caught my eye was feeling that this kind of coverage was not using debug info (like  does) at all, but it was using profiling data, coming directly from the darkest parts of LLVM.My curiosity took me to some extraordinary places in the LLVM codebase…I wanted to understand what the  was causing.Also, I wanted to know how I got a binary file () without my code writing anything to the disk.And what it contained..<br>It contains the globals that the  instruments into your code.But we probably need to move one step at a time to learn something new.So, this is the dummy C code -  - that I used to walk myself through this study.I compiled it to textual LLVM IR:In a matter of milliseconds, I was able to look at its intermediate representation:It stands out from what we see that it contains:Also, all these variables have ELF sections.The  variables end up into the  section.
The  variables end up into the  section.
The  variable ends up into the  section.But what  variables are?The section names helped me here: they are the  used by LLVM for instrumenting our code for !Scrolling down into the LLVM IR, we see they’re getting incremented (, ,  instructions sequence) at the correct spots:We now know why the  array has size 3 (see ): LLVM instrumented one counter for the  function’s entry, one for the  block, while the last one regards the  block.We also know that we have a total of 5 counters, given the  and  have both size 1.Verifying this is just a matter of obtaining our program binary…And playing with :The output here helps us confirm that we have 5 total counters of 8 bytes each, starting at address  and ending at .In fact, $c138 - c110 = 28$, which means 40 bytes in decimal base (ie., $8 * 5$).What about the  variables instead?At the moment, all you need to know is that those are structs containing data about the function they refer to and the instrumented counters for it.I hope the following image clarifies the relationship.<br>Anyways, we’ll dig deeper into the  variables .At this point, I still didn’t know  the  file got created every time I executed my binary.I came back to the LLVM source code.<br>It’s incredible the superpowers that reading the source gives you…I found .Long story short: the code in this LLVM source file implements the , which means it is responsible for gathering all the data from the variables (counters, data, etc.) we’ve seen and flushing them out in the  file.While looking at it, I suddenly noticed the  function.It gets invoked by the profiling runtime initialization hook to get the filename of the profraw to create.<br>Either from an environment variable () or using the default one ().<br>Finally, it calls the C library function .<br>Which will cause the  function to be invoked when the program terminates.Thus, I also noticed the  function.The main thing this function does is to invoke .<br>Which, in turn, calls  .It’s again time to verify with .Our ELF got flooded by  functions.Seeing all those symbols in the ELF made me 100% sure this is how LLVM makes our binary open the  file as soon it executes.<br>In this way, it also makes our program automatically dump the profile data when it terminates.Coming back to the  function implementation (in the  source file), we instead discover  it dumps into .<br>It’s while doing so that we understand what a profraw file contains.Such a function:All these moving parts are written using the  data structure.So, we can finally assert what a profraw binary file is composed by:The  macro at  defines the parts composing the header of the profraw file.<br>Which are:With the following table I tried to summarize the header’s content:But probably an image is worth a thousand words.This is the  file after executing :We can see that its header is composed of:Exactly the way we were now expecting it.Focusing on the data part, I’ve highlighted with (orange) rectangles the 3  global variables.Each of the  contains 6 parts:After the data parte comes the counters part.It just is a serialization of what the variables in the  ELF section contains.In fact, in this screenshot you can see underlined (with waves, in shades of cyan/blue):Finally, the  variable populates the last part of the profraw file.Here (in grey) you can see its content, padded with a  byte (the one circled) at the end to align the profraw file size to be multiple of 8.It’s time to use the  file now:Isn’t it cool?There’s more you can do with profraw files and the LLVM toolchain, indeed.<br>But showing that was not the goal of this post.I hope you now have a better understanding of what profraw files are.Three months ago, I was looking into building coverage for eBPF programs.That’s how  was born.I did not want to reinvent the wheel, so I was looking into the existing coverage instrumentation features of LLVM.Among the different options LLVM provides,  suddenly appeared very appealing to me.It’s the most precise type of code coverage.<br>In my opinion, the only one that gives its user a damn clue on what code region of the program is executing.<br>It also helps understand why a particular code branch gets executed.Using it is pretty straightforward.<br>All resolve to the following steps:You now have a beautifully fine-grained coverage report for your C/C++ code.But what caught my eye was feeling that this kind of coverage was not using debug info (like  does) at all, but it was using profiling data, coming directly from the darkest parts of LLVM.My curiosity took me to some extraordinary places in the LLVM codebase…I wanted to understand what the  was causing.Also, I wanted to know how I got a binary file () without my code writing anything to the disk.And what it contained..<br>It contains the globals that the  instruments into your code.But we probably need to move one step at a time to learn something new.So, this is the dummy C code -  - that I used to walk myself through this study.I compiled it to textual LLVM IR:In a matter of milliseconds, I was able to look at its intermediate representation:It stands out from what we see that it contains:Also, all these variables have ELF sections.The  variables end up into the  section.
The  variables end up into the  section.
The  variable ends up into the  section.But what  variables are?The section names helped me here: they are the  used by LLVM for instrumenting our code for !Scrolling down into the LLVM IR, we see they’re getting incremented (, ,  instructions sequence) at the correct spots:We now know why the  array has size 3 (see ): LLVM instrumented one counter for the  function’s entry, one for the  block, while the last one regards the  block.We also know that we have a total of 5 counters, given the  and  have both size 1.Verifying this is just a matter of obtaining our program binary…And playing with :The output here helps us confirm that we have 5 total counters of 8 bytes each, starting at address  and ending at .In fact, $c138 - c110 = 28$, which means 40 bytes in decimal base (ie., $8 * 5$).What about the  variables instead?At the moment, all you need to know is that those are structs containing data about the function they refer to and the instrumented counters for it.I hope the following image clarifies the relationship.<br>Anyways, we’ll dig deeper into the  variables .At this point, I still didn’t know  the  file got created every time I executed my binary.I came back to the LLVM source code.<br>It’s incredible the superpowers that reading the source gives you…I found .Long story short: the code in this LLVM source file implements the , which means it is responsible for gathering all the data from the variables (counters, data, etc.) we’ve seen and flushing them out in the  file.While looking at it, I suddenly noticed the  function.It gets invoked by the profiling runtime initialization hook to get the filename of the profraw to create.<br>Either from an environment variable () or using the default one ().<br>Finally, it calls the C library function .<br>Which will cause the  function to be invoked when the program terminates.Thus, I also noticed the  function.The main thing this function does is to invoke .<br>Which, in turn, calls  .It’s again time to verify with .Our ELF got flooded by  functions.Seeing all those symbols in the ELF made me 100% sure this is how LLVM makes our binary open the  file as soon it executes.<br>In this way, it also makes our program automatically dump the profile data when it terminates.Coming back to the  function implementation (in the  source file), we instead discover  it dumps into .<br>It’s while doing so that we understand what a profraw file contains.Such a function:All these moving parts are written using the  data structure.So, we can finally assert what a profraw binary file is composed by:The  macro at  defines the parts composing the header of the profraw file.<br>Which are:With the following table I tried to summarize the header’s content:But probably an image is worth a thousand words.This is the  file after executing :We can see that its header is composed of:Exactly the way we were now expecting it.Focusing on the data part, I’ve highlighted with (orange) rectangles the 3  global variables.Each of the  contains 6 parts:After the data parte comes the counters part.It just is a serialization of what the variables in the  ELF section contains.In fact, in this screenshot you can see underlined (with waves, in shades of cyan/blue):Finally, the  variable populates the last part of the profraw file.Here (in grey) you can see its content, padded with a  byte (the one circled) at the end to align the profraw file size to be multiple of 8.It’s time to use the  file now:Isn’t it cool?There’s more you can do with profraw files and the LLVM toolchain, indeed.<br>But showing that was not the goal of this post.I hope you now have a better understanding of what profraw files are.Three months ago, I was looking into building coverage for eBPF programs.That’s how  was born.I did not want to reinvent the wheel, so I was looking into the existing coverage instrumentation features of LLVM.Among the different options LLVM provides,  suddenly appeared very appealing to me.It’s the most precise type of code coverage.<br>In my opinion, the only one that gives its user a damn clue on what code region of the program is executing.<br>It also helps understand why a particular code branch gets executed.Using it is pretty straightforward.<br>All resolve to the following steps:You now have a beautifully fine-grained coverage report for your C/C++ code.But what caught my eye was feeling that this kind of coverage was not using debug info (like  does) at all, but it was using profiling data, coming directly from the darkest parts of LLVM.My curiosity took me to some extraordinary places in the LLVM codebase…I wanted to understand what the  was causing.Also, I wanted to know how I got a binary file () without my code writing anything to the disk.And what it contained..<br>It contains the globals that the  instruments into your code.But we probably need to move one step at a time to learn something new.So, this is the dummy C code -  - that I used to walk myself through this study.I compiled it to textual LLVM IR:In a matter of milliseconds, I was able to look at its intermediate representation:It stands out from what we see that it contains:Also, all these variables have ELF sections.The  variables end up into the  section.
The  variables end up into the  section.
The  variable ends up into the  section.But what  variables are?The section names helped me here: they are the  used by LLVM for instrumenting our code for !Scrolling down into the LLVM IR, we see they’re getting incremented (, ,  instructions sequence) at the correct spots:We now know why the  array has size 3 (see ): LLVM instrumented one counter for the  function’s entry, one for the  block, while the last one regards the  block.We also know that we have a total of 5 counters, given the  and  have both size 1.Verifying this is just a matter of obtaining our program binary…And playing with :The output here helps us confirm that we have 5 total counters of 8 bytes each, starting at address  and ending at .In fact, $c138 - c110 = 28$, which means 40 bytes in decimal base (ie., $8 * 5$).What about the  variables instead?At the moment, all you need to know is that those are structs containing data about the function they refer to and the instrumented counters for it.I hope the following image clarifies the relationship.<br>Anyways, we’ll dig deeper into the  variables .At this point, I still didn’t know  the  file got created every time I executed my binary.I came back to the LLVM source code.<br>It’s incredible the superpowers that reading the source gives you…I found .Long story short: the code in this LLVM source file implements the , which means it is responsible for gathering all the data from the variables (counters, data, etc.) we’ve seen and flushing them out in the  file.While looking at it, I suddenly noticed the  function.It gets invoked by the profiling runtime initialization hook to get the filename of the profraw to create.<br>Either from an environment variable () or using the default one ().<br>Finally, it calls the C library function .<br>Which will cause the  function to be invoked when the program terminates.Thus, I also noticed the  function.The main thing this function does is to invoke .<br>Which, in turn, calls  .It’s again time to verify with .Our ELF got flooded by  functions.Seeing all those symbols in the ELF made me 100% sure this is how LLVM makes our binary open the  file as soon it executes.<br>In this way, it also makes our program automatically dump the profile data when it terminates.Coming back to the  function implementation (in the  source file), we instead discover  it dumps into .<br>It’s while doing so that we understand what a profraw file contains.Such a function:All these moving parts are written using the  data structure.So, we can finally assert what a profraw binary file is composed by:The  macro at  defines the parts composing the header of the profraw file.<br>Which are:With the following table I tried to summarize the header’s content:But probably an image is worth a thousand words.This is the  file after executing :We can see that its header is composed of:Exactly the way we were now expecting it.Focusing on the data part, I’ve highlighted with (orange) rectangles the 3  global variables.Each of the  contains 6 parts:After the data parte comes the counters part.It just is a serialization of what the variables in the  ELF section contains.In fact, in this screenshot you can see underlined (with waves, in shades of cyan/blue):Finally, the  variable populates the last part of the profraw file.Here (in grey) you can see its content, padded with a  byte (the one circled) at the end to align the profraw file size to be multiple of 8.It’s time to use the  file now:Isn’t it cool?There’s more you can do with profraw files and the LLVM toolchain, indeed.<br>But showing that was not the goal of this post.I hope you now have a better understanding of what profraw files are.Three months ago, I was looking into building coverage for eBPF programs.That’s how  was born.I did not want to reinvent the wheel, so I was looking into the existing coverage instrumentation features of LLVM.Among the different options LLVM provides,  suddenly appeared very appealing to me.It’s the most precise type of code coverage.<br>In my opinion, the only one that gives its user a damn clue on what code region of the program is executing.<br>It also helps understand why a particular code branch gets executed.Using it is pretty straightforward.<br>All resolve to the following steps:You now have a beautifully fine-grained coverage report for your C/C++ code.But what caught my eye was feeling that this kind of coverage was not using debug info (like  does) at all, but it was using profiling data, coming directly from the darkest parts of LLVM.My curiosity took me to some extraordinary places in the LLVM codebase…I wanted to understand what the  was causing.Also, I wanted to know how I got a binary file () without my code writing anything to the disk.And what it contained..<br>It contains the globals that the  instruments into your code.But we probably need to move one step at a time to learn something new.So, this is the dummy C code -  - that I used to walk myself through this study.I compiled it to textual LLVM IR:In a matter of milliseconds, I was able to look at its intermediate representation:It stands out from what we see that it contains:Also, all these variables have ELF sections.The  variables end up into the  section.
The  variables end up into the  section.
The  variable ends up into the  section.But what  variables are?The section names helped me here: they are the  used by LLVM for instrumenting our code for !Scrolling down into the LLVM IR, we see they’re getting incremented (, ,  instructions sequence) at the correct spots:We now know why the  array has size 3 (see ): LLVM instrumented one counter for the  function’s entry, one for the  block, while the last one regards the  block.We also know that we have a total of 5 counters, given the  and  have both size 1.Verifying this is just a matter of obtaining our program binary…And playing with :The output here helps us confirm that we have 5 total counters of 8 bytes each, starting at address  and ending at .In fact, $c138 - c110 = 28$, which means 40 bytes in decimal base (ie., $8 * 5$).What about the  variables instead?At the moment, all you need to know is that those are structs containing data about the function they refer to and the instrumented counters for it.I hope the following image clarifies the relationship.<br>Anyways, we’ll dig deeper into the  variables .At this point, I still didn’t know  the  file got created every time I executed my binary.I came back to the LLVM source code.<br>It’s incredible the superpowers that reading the source gives you…I found .Long story short: the code in this LLVM source file implements the , which means it is responsible for gathering all the data from the variables (counters, data, etc.) we’ve seen and flushing them out in the  file.While looking at it, I suddenly noticed the  function.It gets invoked by the profiling runtime initialization hook to get the filename of the profraw to create.<br>Either from an environment variable () or using the default one ().<br>Finally, it calls the C library function .<br>Which will cause the  function to be invoked when the program terminates.Thus, I also noticed the  function.The main thing this function does is to invoke .<br>Which, in turn, calls  .It’s again time to verify with .Our ELF got flooded by  functions.Seeing all those symbols in the ELF made me 100% sure this is how LLVM makes our binary open the  file as soon it executes.<br>In this way, it also makes our program automatically dump the profile data when it terminates.Coming back to the  function implementation (in the  source file), we instead discover  it dumps into .<br>It’s while doing so that we understand what a profraw file contains.Such a function:All these moving parts are written using the  data structure.So, we can finally assert what a profraw binary file is composed by:The  macro at  defines the parts composing the header of the profraw file.<br>Which are:With the following table I tried to summarize the header’s content:But probably an image is worth a thousand words.This is the  file after executing :We can see that its header is composed of:Exactly the way we were now expecting it.Focusing on the data part, I’ve highlighted with (orange) rectangles the 3  global variables.Each of the  contains 6 parts:After the data parte comes the counters part.It just is a serialization of what the variables in the  ELF section contains.In fact, in this screenshot you can see underlined (with waves, in shades of cyan/blue):Finally, the  variable populates the last part of the profraw file.Here (in grey) you can see its content, padded with a  byte (the one circled) at the end to align the profraw file size to be multiple of 8.It’s time to use the  file now:Isn’t it cool?There’s more you can do with profraw files and the LLVM toolchain, indeed.<br>But showing that was not the goal of this post.I hope you now have a better understanding of what profraw files are.Three months ago, I was looking into building coverage for eBPF programs.That’s how  was born.I did not want to reinvent the wheel, so I was looking into the existing coverage instrumentation features of LLVM.Among the different options LLVM provides,  suddenly appeared very appealing to me.It’s the most precise type of code coverage.<br>In my opinion, the only one that gives its user a damn clue on what code region of the program is executing.<br>It also helps understand why a particular code branch gets executed.Using it is pretty straightforward.<br>All resolve to the following steps:You now have a beautifully fine-grained coverage report for your C/C++ code.But what caught my eye was feeling that this kind of coverage was not using debug info (like  does) at all, but it was using profiling data, coming directly from the darkest parts of LLVM.My curiosity took me to some extraordinary places in the LLVM codebase…I wanted to understand what the  was causing.Also, I wanted to know how I got a binary file () without my code writing anything to the disk.And what it contained..<br>It contains the globals that the  instruments into your code.But we probably need to move one step at a time to learn something new.So, this is the dummy C code -  - that I used to walk myself through this study.I compiled it to textual LLVM IR:In a matter of milliseconds, I was able to look at its intermediate representation:It stands out from what we see that it contains:Also, all these variables have ELF sections.The  variables end up into the  section.
The  variables end up into the  section.
The  variable ends up into the  section.But what  variables are?The section names helped me here: they are the  used by LLVM for instrumenting our code for !Scrolling down into the LLVM IR, we see they’re getting incremented (, ,  instructions sequence) at the correct spots:We now know why the  array has size 3 (see ): LLVM instrumented one counter for the  function’s entry, one for the  block, while the last one regards the  block.We also know that we have a total of 5 counters, given the  and  have both size 1.Verifying this is just a matter of obtaining our program binary…And playing with :The output here helps us confirm that we have 5 total counters of 8 bytes each, starting at address  and ending at .In fact, $c138 - c110 = 28$, which means 40 bytes in decimal base (ie., $8 * 5$).What about the  variables instead?At the moment, all you need to know is that those are structs containing data about the function they refer to and the instrumented counters for it.I hope the following image clarifies the relationship.<br>Anyways, we’ll dig deeper into the  variables .At this point, I still didn’t know  the  file got created every time I executed my binary.I came back to the LLVM source code.<br>It’s incredible the superpowers that reading the source gives you…I found .Long story short: the code in this LLVM source file implements the , which means it is responsible for gathering all the data from the variables (counters, data, etc.) we’ve seen and flushing them out in the  file.While looking at it, I suddenly noticed the  function.It gets invoked by the profiling runtime initialization hook to get the filename of the profraw to create.<br>Either from an environment variable () or using the default one ().<br>Finally, it calls the C library function .<br>Which will cause the  function to be invoked when the program terminates.Thus, I also noticed the  function.The main thing this function does is to invoke .<br>Which, in turn, calls  .It’s again time to verify with .Our ELF got flooded by  functions.Seeing all those symbols in the ELF made me 100% sure this is how LLVM makes our binary open the  file as soon it executes.<br>In this way, it also makes our program automatically dump the profile data when it terminates.Coming back to the  function implementation (in the  source file), we instead discover  it dumps into .<br>It’s while doing so that we understand what a profraw file contains.Such a function:All these moving parts are written using the  data structure.So, we can finally assert what a profraw binary file is composed by:The  macro at  defines the parts composing the header of the profraw file.<br>Which are:With the following table I tried to summarize the header’s content:But probably an image is worth a thousand words.This is the  file after executing :We can see that its header is composed of:Exactly the way we were now expecting it.Focusing on the data part, I’ve highlighted with (orange) rectangles the 3  global variables.Each of the  contains 6 parts:After the data parte comes the counters part.It just is a serialization of what the variables in the  ELF section contains.In fact, in this screenshot you can see underlined (with waves, in shades of cyan/blue):Finally, the  variable populates the last part of the profraw file.Here (in grey) you can see its content, padded with a  byte (the one circled) at the end to align the profraw file size to be multiple of 8.It’s time to use the  file now:Isn’t it cool?There’s more you can do with profraw files and the LLVM toolchain, indeed.<br>But showing that was not the goal of this post.I hope you now have a better understanding of what profraw files are.</p>
