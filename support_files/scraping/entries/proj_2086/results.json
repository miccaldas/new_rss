[
{"title": "Dumpster diving the Go garbage collector", "links": "https://www.cncf.io/projects/pixie", "content": "Natalie Serrino", "images": []},
{"title": "missing", "links": "https://www.cncf.io/projects/pixie", "content": "Go is a garbage collected language. This makes writing Go simpler, because you can spend less time worrying about managing the lifetime of allocated objects.", "images": []},
{"title": "missing", "links": "/", "content": "Memory management is definitely easier in Go than it is in, say, C++. But it\u2019s also not an area we as Go developers can totally ignore, either. Understanding how Go allocates and frees memory allows us to write better, more efficient applications. The garbage collector is a critical piece of that puzzle.", "images": []},
{"title": "missing", "links": "https://slackin.px.dev", "content": "In order to better understand how the garbage collector works, I decided to trace its low-level behavior on a live application. In this investigation, I'll instrument the Go garbage collector with eBPF uprobes. The source code for this post lives ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie", "content": ".", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": "Before diving in, let's get some quick context on uprobes, the garbage collector's design, and the demo application we'll be using.", "images": []},
{"title": "missing", "links": "https://www.youtube.com/channel/UCOMCDRvBVNIS0lCyOmst7eg/featured", "content": " are cool because they let us dynamically collect new information without modifying our code. This is useful when you can\u2019t or don\u2019t want to redeploy your app - maybe because it\u2019s in production, or the interesting behavior is hard to reproduce.", "images": []},
{"title": "missing", "links": "https://docs.px.dev", "content": "Function arguments, return values, latency, and timestamps can all be collected via uprobes. In this post, I'll deploy uprobes onto key functions from the Go garbage collector. This will allow me to see how it behaves in practice in my running application.", "images": []},
{"title": "missing", "links": "https://px.dev/", "content": "Note: this post uses Go 1.16. I will trace private functions in the Go runtime. However, these functions are subject to change in later releases of Go.", "images": []},
{"title": "missing", "links": "/", "content": "Go uses a ", "images": []},
{"title": "missing", "links": "https://px.dev", "content": ". For those unfamiliar with the terms, here is a quick summary so you can understand the rest of the post. You can find more detailed information ", "images": []},
{"title": "missing", "links": "https://docs.px.dev", "content": ", ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie", "content": ", ", "images": []},
{"title": "missing", "links": "https://slackin.px.dev", "content": ", and ", "images": []},
{"title": "missing", "links": "https://www.youtube.com/channel/UCOMCDRvBVNIS0lCyOmst7eg/featured", "content": ".", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": "Go's garbage collector is called ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie", "content": " because it can safely run in parallel with the main program. In other words, it doesn\u2019t need", "images": []},
{"title": "missing", "links": "https://slackin.px.dev", "content": "*", "images": []},
{"title": "missing", "links": "https://www.youtube.com/channel/UCOMCDRvBVNIS0lCyOmst7eg/featured", "content": " to halt the execution of your program to do its job. (", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": "*", "images": []},
{"title": "missing", "links": "/", "content": "more on this later).", "images": []},
{"title": "missing", "links": "/pixie-team-blogs", "content": "There are two major phases of garbage collection:", "images": []},
{"title": "missing", "links": "#title", "content": ": ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie-demos/tree/main/go-garbage-collector", "content": ": ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#a-few-things-before-diving-in", "content": "Here is a simple endpoint that I\u2019ll use in order to trigger the garbage collector. It creates a variably-sized string array. Then it invokes the garbage collector via ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#why-uprobes", "content": ".", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#the-phases-of-garbage-collection", "content": "Usually, you don't need to call the garbage collector manually, because Go handles that for you. However, this guarantees it kicks in after every API call.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#tracing-the-major-phases-of-garbage-collection", "content": "Now that we have some context on uprobes and the basics of Go's garbage collector, let's dive in to observing its behavior.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#tracing-runtime.gc()", "content": "First, I decided to add uprobes to following functions in Go's ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#mark-and-sweep-assists", "content": " library.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#tracing-stop-the-world-events", "content": "(If you\u2019re interested in seeing how the uprobes were generated, here's the ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#how-does-the-garbage-collector-pace-itself", "content": ".)", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#trigger-ratio", "content": "After deploying the uprobes, I hit the endpoint and generated an array containing 10 strings that are each 20 bytes.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#mark-and-sweep-assists", "content": "The deployed uprobes observed the following events after that curl call:", "images": []},
{"title": "missing", "links": "#a-few-things-before-diving-in", "content": "This makes sense from the ", "images": []},
{"title": "missing", "links": "#why-uprobes", "content": " - ", "images": []},
{"title": "missing", "links": "https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#uprobes", "content": " is called twice, once as a validation for the prior cycle before starting the next cycle. The mark phase triggers the sweep phase.", "images": []},
{"title": "missing", "links": "#the-phases-of-garbage-collection", "content": "Next, I took some measurements for ", "images": []},
{"title": "missing", "links": "https://agrim123.github.io/posts/go-garbage-collector.html", "content": " latency after hitting the ", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Tracing_garbage_collection", "content": " endpoint with a variety of inputs.", "images": []},
{"title": "missing", "links": "https://go.dev/blog/ismmkeynote", "content": "While that was a good high level view, we could use more detail. Next, I probed some helper functions for memory allocation, marking, and sweeping to get the next level of information.", "images": []},
{"title": "missing", "links": "https://www.iecc.com/gclist/GC-algorithms.html", "content": "These helper functions have arguments or return values that will help us better visualize what is happening (e.g. pages of memory allocated).", "images": []},
{"title": "missing", "links": "#a-simple-demo-application", "content": "After hitting the garbage collector with a bit more load, here are the raw results:", "images": []},
{"title": "missing", "links": "#tracing-the-major-phases-of-garbage-collection", "content": "They\u2019re easier to interpret when plotted as a timeseries:", "images": []},
{"title": "missing", "links": "#tracing-runtime.gc()", "content": "Now we can see what happened:", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L1126", "content": "\u201cStopping the world\u201d refers to the garbage collector temporarily halting everything but itself in order to safely modify the state. We generally prefer to minimize STW phases, because they slow our programs down (usually when it\u2019s most inconvenient\u2026).", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L1201", "content": "Some garbage collectors stop the world the entire time garbage collection is running. These are \u201cnon concurrent\u201d garbage collectors. While Go\u2019s garbage collector is largely concurrent, we can see from the code that it does technically stop the world in two places.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L2170", "content": "Let's trace the following functions:", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie-demos/tree/main/go-garbage-collector", "content": "And trigger garbage collection again:", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L1126", "content": "The following events were produced by the new probes:", "images": []},
{"title": "missing", "links": "#tracing-the-mark-and-sweep-phases", "content": "We can see from the ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mheap.go#L1124", "content": " event that garbage collection took 3.1 ms to complete. After I inspected the exact timestamps, it turns out the world was stopped for 300 \u00b5s the first time and 365 \u00b5s the second time. In other words, ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgcmark.go#L1095", "content": " of the garbage collection was performed concurrently. We would expect this ratio to get even better when the garbage collector was invoked \u201cnaturally\u201d under real memory pressure.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgcsweep.go#L188", "content": "Why does the Go garbage collector need to stop the world?", "images": []},
{"title": "missing", "links": "#tracing-stop-the-world-events", "content": ": Set up state and turn on the write barrier. The write barrier ensures that new writes are correctly tracked when GC is running (so that they are not accidentally freed or kept around).", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/proc.go#L1073", "content": ": Clean up mark state and turn off the write barrier.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/proc.go#L1151", "content": "Knowing when to run garbage collection is an important consideration for concurrent garbage collectors like Go\u2019s.", "images": []},
{"title": "missing", "links": "#how-does-the-garbage-collector-pace-itself", "content": "Earlier generations of garbage collectors were designed to kick in once they reached a certain level of memory consumption. This works fine if the garbage collector is non-concurrent. ", "images": []},
{"title": "missing", "links": "https://go.googlesource.com/proposal/+/a216b56e743c5b6b300b3ef1673ee62684b5b63b/design/44167-gc-pacer-redesign.md", "content": "This means we can overshoot the memory goal if we run the garbage collector too late. (Go can\u2019t just run garbage collection all of the time, either - GC takes away resources and performance from the main application.)", "images": []},
{"title": "missing", "links": "#trigger-ratio", "content": "Go\u2019s garbage collector uses a ", "images": []},
{"title": "missing", "links": "#mark-and-sweep-assists", "content": " to estimate the optimal times for garbage collection. This helps Go meet its memory and CPU targets without sacrificing more application performance than necessary.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgcmark.go#L504", "content": "As we just established, Go\u2019s concurrent garbage collector relies on a pacer to determine when to do garbage collection. But how does it make that decision?", "images": []},
{"title": "missing", "links": "#wrapping-up", "content": "Every time the garbage collector is called, the pacer updates its internal goal for when it should run GC next. This goal is called the trigger ratio. A trigger ratio of ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/master/src/runtime/mgc.go#L93", "content": " means that the system should run garbage collection again once the heap has gone up ", "images": []},
{"title": "missing", "links": "https://medium.com/a-journey-with-go/go-introduction-to-the-escape-analysis-f7610174e890", "content": " in size. The trigger ratio factors in CPU, memory, and other factors to generate this number.", "images": []},
{"title": "missing", "links": "https://pkg.go.dev/sync#Pool", "content": "Let\u2019s see how the garbage collector\u2019s trigger ratio changes when we allocate a lot of memory at once. We can grab the trigger ratio by tracing the function ", "images": []},
{"title": "missing", "links": "https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72", "content": ".", "images": []},
{"title": "missing", "links": "https://docs.px.dev/tutorials/custom-data/dynamic-go-logging/", "content": "We can see that initially, the trigger ratio is quite high. The runtime has determined that garbage collection won\u2019t be necessary until the program is using ", "images": []},
{"title": "missing", "links": "https://github.com/iovisor/bpftrace", "content": " more memory. This makes sense, because the application isn\u2019t doing much (and not using much of the heap).", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie-demos/tree/main/go-garbage-collector", "content": "However, once we hit the endpoint to create ", "images": []},
{"title": "missing", "links": "https://slackin.px.dev/", "content": " of heap allocations, the trigger ratio quickly drops to ", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": ". Now we need only ", "images": []},
{"title": "missing", "links": "https://twitter.com/@nserrino", "content": " more memory before garbage collection should occur (since our memory consumption rose).", "images": []},
{"title": "missing", "links": "/ebpf-http2-tracing/", "content": "What happens when I allocate memory, but don\u2019t call the garbage collector? Next I\u2019ll hit the ", "images": []},
{"title": "missing", "links": "/endpoint-deprecation/", "content": " endpoint, which does the same thing as ", "images": []},
{"title": "missing", "links": "/tables-are-hard-2/", "content": " but skips the call to ", "images": []},
{"title": "missing", "links": "https://cncf.io/", "content": ".", "images": []},
{"title": "missing", "links": "https://www.linuxfoundation.org/terms", "content": "Based on the most recent trigger ratio, the garbage collector shouldn\u2019t have kicked in yet. ", "images": []},
{"title": "missing", "links": "https://www.linuxfoundation.org/privacy", "content": "It turns out, the garbage collector has another trick up its sleeve to prevent out of control memory growth. ", "images": []},
{"title": "missing", "links": "https://www.linuxfoundation.org/trademark-usage", "content": " Goroutines requesting new heap allocations will first have to assist with garbage collection before getting what they asked for.", "images": []},
{"title": "missing", "links": "https://newrelic.com/", "content": "This \u201cassist\u201d system adds latency to the allocation and therefore helps to backpressure the system. It\u2019s really important, because it solves a problem that can arise from concurrent garbage collectors. In a concurrent garbage collector, memory allocation is still being allocated while garbage collection runs. If the program is allocating memory faster than the garbage collector is freeing it, then memory growth will be unbounded. ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/blog.px.dev", "content": "We can trace ", "images": []},
{"title": "missing", "links": "https://pixielabs.ai/privacy/#Cookies", "content": " to see this process in action. ", "images": []},
{"title": "missing", "links": "missing", "content": " takes in an argument called ", "images": []},
{"title": "missing", "links": "missing", "content": ", which is the amount of assist work requested.", "images": []},
{"title": "missing", "links": "missing", "content": "We can see that ", "images": []},
{"title": "missing", "links": "missing", "content": " is the source of the mark and sweep work. It receives a request to fulfill about ", "images": []},
{"title": "missing", "links": "missing", "content": " units of work. In the previous mark phase diagram, we can see that ", "images": []},
{"title": "missing", "links": "missing", "content": " performs about 300,000 units of mark work at that same time (just spread out a bit).", "images": []},
{"title": "missing", "links": "missing", "content": "There\u2019s a lot more to learn about memory allocation and garbage collection in Go! Here\u2019s some other resources to check out:", "images": []},
{"title": "missing", "links": "missing", "content": "Creating uprobes, like we did in this example, is usually best done in a higher level BPF framework. For this post, I used Pixie\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " feature (which is still in alpha). ", "images": []},
{"title": "missing", "links": "missing", "content": " is another great tool for creating uprobes. You can try out the entire example from this post ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "Another good option for inspecting the behavior of the Go garbage collector is the gc tracer. Just pass in ", "images": []},
{"title": "missing", "links": "missing", "content": " when you start your program. It requires a restart, but will tell you all kinds of cool information about what the garbage collector is doing.", "images": []},
{"title": "missing", "links": "missing", "content": "Questions? Find the Pixie contributors on ", "images": []},
{"title": "missing", "links": "missing", "content": " or Twitter at ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "Natalie Serrino", "images": []},
{"title": "missing", "links": "missing", "content": "Related Stories", "images": []},
{"title": "missing", "links": "missing", "content": "Yaxiong Zhao", "images": []},
{"title": "missing", "links": "missing", "content": "Jan 19, 2022", "images": []},
{"title": "missing", "links": "missing", "content": "Hannah Troisi", "images": []},
{"title": "missing", "links": "missing", "content": "Jan 11, 2022", "images": []},
{"title": "missing", "links": "missing", "content": "Nick Lanam", "images": []},
{"title": "missing", "links": "missing", "content": "Dec 14, 2021", "images": []},
{"title": "missing", "links": "missing", "content": "We are a", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": "sandbox project.", "images": []}
][
{"title": "Dumpster diving the Go garbage collector", "links": "https://www.cncf.io/projects/pixie", "content": "Natalie Serrino", "images": []},
{"title": "missing", "links": "https://www.cncf.io/projects/pixie", "content": "Go is a garbage collected language. This makes writing Go simpler, because you can spend less time worrying about managing the lifetime of allocated objects.", "images": []},
{"title": "missing", "links": "/", "content": "Memory management is definitely easier in Go than it is in, say, C++. But it\u2019s also not an area we as Go developers can totally ignore, either. Understanding how Go allocates and frees memory allows us to write better, more efficient applications. The garbage collector is a critical piece of that puzzle.", "images": []},
{"title": "missing", "links": "https://slackin.px.dev", "content": "In order to better understand how the garbage collector works, I decided to trace its low-level behavior on a live application. In this investigation, I'll instrument the Go garbage collector with eBPF uprobes. The source code for this post lives ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie", "content": ".", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": "Before diving in, let's get some quick context on uprobes, the garbage collector's design, and the demo application we'll be using.", "images": []},
{"title": "missing", "links": "https://www.youtube.com/channel/UCOMCDRvBVNIS0lCyOmst7eg/featured", "content": " are cool because they let us dynamically collect new information without modifying our code. This is useful when you can\u2019t or don\u2019t want to redeploy your app - maybe because it\u2019s in production, or the interesting behavior is hard to reproduce.", "images": []},
{"title": "missing", "links": "https://docs.px.dev", "content": "Function arguments, return values, latency, and timestamps can all be collected via uprobes. In this post, I'll deploy uprobes onto key functions from the Go garbage collector. This will allow me to see how it behaves in practice in my running application.", "images": []},
{"title": "missing", "links": "https://px.dev/", "content": "Note: this post uses Go 1.16. I will trace private functions in the Go runtime. However, these functions are subject to change in later releases of Go.", "images": []},
{"title": "missing", "links": "/", "content": "Go uses a ", "images": []},
{"title": "missing", "links": "https://px.dev", "content": ". For those unfamiliar with the terms, here is a quick summary so you can understand the rest of the post. You can find more detailed information ", "images": []},
{"title": "missing", "links": "https://docs.px.dev", "content": ", ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie", "content": ", ", "images": []},
{"title": "missing", "links": "https://slackin.px.dev", "content": ", and ", "images": []},
{"title": "missing", "links": "https://www.youtube.com/channel/UCOMCDRvBVNIS0lCyOmst7eg/featured", "content": ".", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": "Go's garbage collector is called ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie", "content": " because it can safely run in parallel with the main program. In other words, it doesn\u2019t need", "images": []},
{"title": "missing", "links": "https://slackin.px.dev", "content": "*", "images": []},
{"title": "missing", "links": "https://www.youtube.com/channel/UCOMCDRvBVNIS0lCyOmst7eg/featured", "content": " to halt the execution of your program to do its job. (", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": "*", "images": []},
{"title": "missing", "links": "/", "content": "more on this later).", "images": []},
{"title": "missing", "links": "/pixie-team-blogs", "content": "There are two major phases of garbage collection:", "images": []},
{"title": "missing", "links": "#title", "content": ": ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie-demos/tree/main/go-garbage-collector", "content": ": ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#a-few-things-before-diving-in", "content": "Here is a simple endpoint that I\u2019ll use in order to trigger the garbage collector. It creates a variably-sized string array. Then it invokes the garbage collector via ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#why-uprobes", "content": ".", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#the-phases-of-garbage-collection", "content": "Usually, you don't need to call the garbage collector manually, because Go handles that for you. However, this guarantees it kicks in after every API call.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#tracing-the-major-phases-of-garbage-collection", "content": "Now that we have some context on uprobes and the basics of Go's garbage collector, let's dive in to observing its behavior.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#tracing-runtime.gc()", "content": "First, I decided to add uprobes to following functions in Go's ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#mark-and-sweep-assists", "content": " library.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#tracing-stop-the-world-events", "content": "(If you\u2019re interested in seeing how the uprobes were generated, here's the ", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#how-does-the-garbage-collector-pace-itself", "content": ".)", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#trigger-ratio", "content": "After deploying the uprobes, I hit the endpoint and generated an array containing 10 strings that are each 20 bytes.", "images": []},
{"title": "missing", "links": "/go-garbage-collector/#mark-and-sweep-assists", "content": "The deployed uprobes observed the following events after that curl call:", "images": []},
{"title": "missing", "links": "#a-few-things-before-diving-in", "content": "This makes sense from the ", "images": []},
{"title": "missing", "links": "#why-uprobes", "content": " - ", "images": []},
{"title": "missing", "links": "https://jvns.ca/blog/2017/07/05/linux-tracing-systems/#uprobes", "content": " is called twice, once as a validation for the prior cycle before starting the next cycle. The mark phase triggers the sweep phase.", "images": []},
{"title": "missing", "links": "#the-phases-of-garbage-collection", "content": "Next, I took some measurements for ", "images": []},
{"title": "missing", "links": "https://agrim123.github.io/posts/go-garbage-collector.html", "content": " latency after hitting the ", "images": []},
{"title": "missing", "links": "https://en.wikipedia.org/wiki/Tracing_garbage_collection", "content": " endpoint with a variety of inputs.", "images": []},
{"title": "missing", "links": "https://go.dev/blog/ismmkeynote", "content": "While that was a good high level view, we could use more detail. Next, I probed some helper functions for memory allocation, marking, and sweeping to get the next level of information.", "images": []},
{"title": "missing", "links": "https://www.iecc.com/gclist/GC-algorithms.html", "content": "These helper functions have arguments or return values that will help us better visualize what is happening (e.g. pages of memory allocated).", "images": []},
{"title": "missing", "links": "#a-simple-demo-application", "content": "After hitting the garbage collector with a bit more load, here are the raw results:", "images": []},
{"title": "missing", "links": "#tracing-the-major-phases-of-garbage-collection", "content": "They\u2019re easier to interpret when plotted as a timeseries:", "images": []},
{"title": "missing", "links": "#tracing-runtime.gc()", "content": "Now we can see what happened:", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L1126", "content": "\u201cStopping the world\u201d refers to the garbage collector temporarily halting everything but itself in order to safely modify the state. We generally prefer to minimize STW phases, because they slow our programs down (usually when it\u2019s most inconvenient\u2026).", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L1201", "content": "Some garbage collectors stop the world the entire time garbage collection is running. These are \u201cnon concurrent\u201d garbage collectors. While Go\u2019s garbage collector is largely concurrent, we can see from the code that it does technically stop the world in two places.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L2170", "content": "Let's trace the following functions:", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie-demos/tree/main/go-garbage-collector", "content": "And trigger garbage collection again:", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgc.go#L1126", "content": "The following events were produced by the new probes:", "images": []},
{"title": "missing", "links": "#tracing-the-mark-and-sweep-phases", "content": "We can see from the ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mheap.go#L1124", "content": " event that garbage collection took 3.1 ms to complete. After I inspected the exact timestamps, it turns out the world was stopped for 300 \u00b5s the first time and 365 \u00b5s the second time. In other words, ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgcmark.go#L1095", "content": " of the garbage collection was performed concurrently. We would expect this ratio to get even better when the garbage collector was invoked \u201cnaturally\u201d under real memory pressure.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgcsweep.go#L188", "content": "Why does the Go garbage collector need to stop the world?", "images": []},
{"title": "missing", "links": "#tracing-stop-the-world-events", "content": ": Set up state and turn on the write barrier. The write barrier ensures that new writes are correctly tracked when GC is running (so that they are not accidentally freed or kept around).", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/proc.go#L1073", "content": ": Clean up mark state and turn off the write barrier.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/proc.go#L1151", "content": "Knowing when to run garbage collection is an important consideration for concurrent garbage collectors like Go\u2019s.", "images": []},
{"title": "missing", "links": "#how-does-the-garbage-collector-pace-itself", "content": "Earlier generations of garbage collectors were designed to kick in once they reached a certain level of memory consumption. This works fine if the garbage collector is non-concurrent. ", "images": []},
{"title": "missing", "links": "https://go.googlesource.com/proposal/+/a216b56e743c5b6b300b3ef1673ee62684b5b63b/design/44167-gc-pacer-redesign.md", "content": "This means we can overshoot the memory goal if we run the garbage collector too late. (Go can\u2019t just run garbage collection all of the time, either - GC takes away resources and performance from the main application.)", "images": []},
{"title": "missing", "links": "#trigger-ratio", "content": "Go\u2019s garbage collector uses a ", "images": []},
{"title": "missing", "links": "#mark-and-sweep-assists", "content": " to estimate the optimal times for garbage collection. This helps Go meet its memory and CPU targets without sacrificing more application performance than necessary.", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/go1.16/src/runtime/mgcmark.go#L504", "content": "As we just established, Go\u2019s concurrent garbage collector relies on a pacer to determine when to do garbage collection. But how does it make that decision?", "images": []},
{"title": "missing", "links": "#wrapping-up", "content": "Every time the garbage collector is called, the pacer updates its internal goal for when it should run GC next. This goal is called the trigger ratio. A trigger ratio of ", "images": []},
{"title": "missing", "links": "https://github.com/golang/go/blob/master/src/runtime/mgc.go#L93", "content": " means that the system should run garbage collection again once the heap has gone up ", "images": []},
{"title": "missing", "links": "https://medium.com/a-journey-with-go/go-introduction-to-the-escape-analysis-f7610174e890", "content": " in size. The trigger ratio factors in CPU, memory, and other factors to generate this number.", "images": []},
{"title": "missing", "links": "https://pkg.go.dev/sync#Pool", "content": "Let\u2019s see how the garbage collector\u2019s trigger ratio changes when we allocate a lot of memory at once. We can grab the trigger ratio by tracing the function ", "images": []},
{"title": "missing", "links": "https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72", "content": ".", "images": []},
{"title": "missing", "links": "https://docs.px.dev/tutorials/custom-data/dynamic-go-logging/", "content": "We can see that initially, the trigger ratio is quite high. The runtime has determined that garbage collection won\u2019t be necessary until the program is using ", "images": []},
{"title": "missing", "links": "https://github.com/iovisor/bpftrace", "content": " more memory. This makes sense, because the application isn\u2019t doing much (and not using much of the heap).", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/pixie-demos/tree/main/go-garbage-collector", "content": "However, once we hit the endpoint to create ", "images": []},
{"title": "missing", "links": "https://slackin.px.dev/", "content": " of heap allocations, the trigger ratio quickly drops to ", "images": []},
{"title": "missing", "links": "https://twitter.com/pixie_run", "content": ". Now we need only ", "images": []},
{"title": "missing", "links": "https://twitter.com/@nserrino", "content": " more memory before garbage collection should occur (since our memory consumption rose).", "images": []},
{"title": "missing", "links": "/ebpf-http2-tracing/", "content": "What happens when I allocate memory, but don\u2019t call the garbage collector? Next I\u2019ll hit the ", "images": []},
{"title": "missing", "links": "/endpoint-deprecation/", "content": " endpoint, which does the same thing as ", "images": []},
{"title": "missing", "links": "/tables-are-hard-2/", "content": " but skips the call to ", "images": []},
{"title": "missing", "links": "https://cncf.io/", "content": ".", "images": []},
{"title": "missing", "links": "https://www.linuxfoundation.org/terms", "content": "Based on the most recent trigger ratio, the garbage collector shouldn\u2019t have kicked in yet. ", "images": []},
{"title": "missing", "links": "https://www.linuxfoundation.org/privacy", "content": "It turns out, the garbage collector has another trick up its sleeve to prevent out of control memory growth. ", "images": []},
{"title": "missing", "links": "https://www.linuxfoundation.org/trademark-usage", "content": " Goroutines requesting new heap allocations will first have to assist with garbage collection before getting what they asked for.", "images": []},
{"title": "missing", "links": "https://newrelic.com/", "content": "This \u201cassist\u201d system adds latency to the allocation and therefore helps to backpressure the system. It\u2019s really important, because it solves a problem that can arise from concurrent garbage collectors. In a concurrent garbage collector, memory allocation is still being allocated while garbage collection runs. If the program is allocating memory faster than the garbage collector is freeing it, then memory growth will be unbounded. ", "images": []},
{"title": "missing", "links": "https://github.com/pixie-io/blog.px.dev", "content": "We can trace ", "images": []},
{"title": "missing", "links": "https://pixielabs.ai/privacy/#Cookies", "content": " to see this process in action. ", "images": []},
{"title": "missing", "links": "missing", "content": " takes in an argument called ", "images": []},
{"title": "missing", "links": "missing", "content": ", which is the amount of assist work requested.", "images": []},
{"title": "missing", "links": "missing", "content": "We can see that ", "images": []},
{"title": "missing", "links": "missing", "content": " is the source of the mark and sweep work. It receives a request to fulfill about ", "images": []},
{"title": "missing", "links": "missing", "content": " units of work. In the previous mark phase diagram, we can see that ", "images": []},
{"title": "missing", "links": "missing", "content": " performs about 300,000 units of mark work at that same time (just spread out a bit).", "images": []},
{"title": "missing", "links": "missing", "content": "There\u2019s a lot more to learn about memory allocation and garbage collection in Go! Here\u2019s some other resources to check out:", "images": []},
{"title": "missing", "links": "missing", "content": "Creating uprobes, like we did in this example, is usually best done in a higher level BPF framework. For this post, I used Pixie\u2019s ", "images": []},
{"title": "missing", "links": "missing", "content": " feature (which is still in alpha). ", "images": []},
{"title": "missing", "links": "missing", "content": " is another great tool for creating uprobes. You can try out the entire example from this post ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "Another good option for inspecting the behavior of the Go garbage collector is the gc tracer. Just pass in ", "images": []},
{"title": "missing", "links": "missing", "content": " when you start your program. It requires a restart, but will tell you all kinds of cool information about what the garbage collector is doing.", "images": []},
{"title": "missing", "links": "missing", "content": "Questions? Find the Pixie contributors on ", "images": []},
{"title": "missing", "links": "missing", "content": " or Twitter at ", "images": []},
{"title": "missing", "links": "missing", "content": ".", "images": []},
{"title": "missing", "links": "missing", "content": "Natalie Serrino", "images": []},
{"title": "missing", "links": "missing", "content": "Related Stories", "images": []},
{"title": "missing", "links": "missing", "content": "Yaxiong Zhao", "images": []},
{"title": "missing", "links": "missing", "content": "Jan 19, 2022", "images": []},
{"title": "missing", "links": "missing", "content": "Hannah Troisi", "images": []},
{"title": "missing", "links": "missing", "content": "Jan 11, 2022", "images": []},
{"title": "missing", "links": "missing", "content": "Nick Lanam", "images": []},
{"title": "missing", "links": "missing", "content": "Dec 14, 2021", "images": []},
{"title": "missing", "links": "missing", "content": "We are a", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": " ", "images": []},
{"title": "missing", "links": "missing", "content": "sandbox project.", "images": []}
]