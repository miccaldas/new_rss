<p>Interested in working with us? We are hiring!Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice.<br>It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company.<br>You can learn all about Hack Week .As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it.<br>Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects.<br>Last year, a group of us worked on extending my .<br>This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability.<br>And so we decided to port the classic  to Rust.id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality.<br>Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles.<br> by David Kushner tells the story; Fabien Sanglard’s  explains the technical details.Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general.<br>In addition, because its technology is more primitive, the source code is more approachable for study and implementation.<br>The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called .<br>All the drawing is done by directly putting pixels on the screen.A few years ago, after reading the Wolfenstein black book, I spent some time trying to , based on another modern port, .<br>I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project.<br>More recently, , who also read the book, proposed a Rust port as a project for this Hack Week.<br>Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before.<br>We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc.<br>This allowed us to make progress in parallel.The first task of porting the game is to read its data.<br>Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps.<br>One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods.<br>For Rustenstein, we used the .WL1 files of the shareware version, which we .Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C ) as well as a Page Manager to move assets from disk to RAM.<br>Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.Parsing and decompression code can be found  for maps, and  for the rest of the assets.Wolfenstein 3D maps are defined as 64x64 grids of tiles.<br>Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items.<br>The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc.<br>All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.Below is the first map of the first episode, as seen in a Wolfenstein map editor:And the same map as ASCII, as printed by our debugging code:For the graphic assets, decompressing and loading the data to memory is just half of the story.<br>The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for.<br>This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D.<br>The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in .<br>Since the  use a different set of abstractions (and, in particular, they don’t expose the  function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas.<br>This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork.<br>The first routine handles displaying a full image directly to the screen.<br>This is used for the title screen as well as the player status bar at the bottom of the in-game view:The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon.<br>A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.The related code can be found .At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm.<br>This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations.<br>The algorithm can be summarized as follows:Below is a simplified JavaScript version of the algorithm, based on :For a ray casting implementation closer to the original Wolfenstein 3D one,  is recommended.This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time.<br>First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures.<br>Second,  figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on  statements and had a lot of global side-effects in addition to calculating wall heights).Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:The full implementation can be found .The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color.<br>After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate.<br>While the algorithm was still in development, we tested the rendering code with hard-coded walls:Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:The , then, looks like this:A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project.<br>In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session.<br>We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before.<br>During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own.<br>And the project ended up winning the technical award of the event!The prototype is now , although, as said, the code still needs significant clean-up.<br>Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it.<br>Some of the features that we could tackle next are: Ready to be part of something incredible? See what’s possible when we roll together.<br>Interested in working with us? We are hiring!Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice.<br>It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company.<br>You can learn all about Hack Week .As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it.<br>Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects.<br>Last year, a group of us worked on extending my .<br>This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability.<br>And so we decided to port the classic  to Rust.id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality.<br>Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles.<br> by David Kushner tells the story; Fabien Sanglard’s  explains the technical details.Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general.<br>In addition, because its technology is more primitive, the source code is more approachable for study and implementation.<br>The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called .<br>All the drawing is done by directly putting pixels on the screen.A few years ago, after reading the Wolfenstein black book, I spent some time trying to , based on another modern port, .<br>I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project.<br>More recently, , who also read the book, proposed a Rust port as a project for this Hack Week.<br>Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before.<br>We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc.<br>This allowed us to make progress in parallel.The first task of porting the game is to read its data.<br>Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps.<br>One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods.<br>For Rustenstein, we used the .WL1 files of the shareware version, which we .Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C ) as well as a Page Manager to move assets from disk to RAM.<br>Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.Parsing and decompression code can be found  for maps, and  for the rest of the assets.Wolfenstein 3D maps are defined as 64x64 grids of tiles.<br>Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items.<br>The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc.<br>All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.Below is the first map of the first episode, as seen in a Wolfenstein map editor:And the same map as ASCII, as printed by our debugging code:For the graphic assets, decompressing and loading the data to memory is just half of the story.<br>The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for.<br>This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D.<br>The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in .<br>Since the  use a different set of abstractions (and, in particular, they don’t expose the  function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas.<br>This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork.<br>The first routine handles displaying a full image directly to the screen.<br>This is used for the title screen as well as the player status bar at the bottom of the in-game view:The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon.<br>A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.The related code can be found .At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm.<br>This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations.<br>The algorithm can be summarized as follows:Below is a simplified JavaScript version of the algorithm, based on :For a ray casting implementation closer to the original Wolfenstein 3D one,  is recommended.This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time.<br>First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures.<br>Second,  figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on  statements and had a lot of global side-effects in addition to calculating wall heights).Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:The full implementation can be found .The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color.<br>After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate.<br>While the algorithm was still in development, we tested the rendering code with hard-coded walls:Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:The , then, looks like this:A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project.<br>In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session.<br>We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before.<br>During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own.<br>And the project ended up winning the technical award of the event!The prototype is now , although, as said, the code still needs significant clean-up.<br>Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it.<br>Some of the features that we could tackle next are: Ready to be part of something incredible? See what’s possible when we roll together.<br>Interested in working with us? We are hiring!Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice.<br>It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company.<br>You can learn all about Hack Week .As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it.<br>Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects.<br>Last year, a group of us worked on extending my .<br>This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability.<br>And so we decided to port the classic  to Rust.id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality.<br>Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles.<br> by David Kushner tells the story; Fabien Sanglard’s  explains the technical details.Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general.<br>In addition, because its technology is more primitive, the source code is more approachable for study and implementation.<br>The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called .<br>All the drawing is done by directly putting pixels on the screen.A few years ago, after reading the Wolfenstein black book, I spent some time trying to , based on another modern port, .<br>I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project.<br>More recently, , who also read the book, proposed a Rust port as a project for this Hack Week.<br>Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before.<br>We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc.<br>This allowed us to make progress in parallel.The first task of porting the game is to read its data.<br>Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps.<br>One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods.<br>For Rustenstein, we used the .WL1 files of the shareware version, which we .Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C ) as well as a Page Manager to move assets from disk to RAM.<br>Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.Parsing and decompression code can be found  for maps, and  for the rest of the assets.Wolfenstein 3D maps are defined as 64x64 grids of tiles.<br>Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items.<br>The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc.<br>All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.Below is the first map of the first episode, as seen in a Wolfenstein map editor:And the same map as ASCII, as printed by our debugging code:For the graphic assets, decompressing and loading the data to memory is just half of the story.<br>The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for.<br>This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D.<br>The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in .<br>Since the  use a different set of abstractions (and, in particular, they don’t expose the  function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas.<br>This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork.<br>The first routine handles displaying a full image directly to the screen.<br>This is used for the title screen as well as the player status bar at the bottom of the in-game view:The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon.<br>A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.The related code can be found .At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm.<br>This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations.<br>The algorithm can be summarized as follows:Below is a simplified JavaScript version of the algorithm, based on :For a ray casting implementation closer to the original Wolfenstein 3D one,  is recommended.This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time.<br>First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures.<br>Second,  figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on  statements and had a lot of global side-effects in addition to calculating wall heights).Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:The full implementation can be found .The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color.<br>After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate.<br>While the algorithm was still in development, we tested the rendering code with hard-coded walls:Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:The , then, looks like this:A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project.<br>In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session.<br>We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before.<br>During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own.<br>And the project ended up winning the technical award of the event!The prototype is now , although, as said, the code still needs significant clean-up.<br>Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it.<br>Some of the features that we could tackle next are: Ready to be part of something incredible? See what’s possible when we roll together.<br>Interested in working with us? We are hiring!Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice.<br>It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company.<br>You can learn all about Hack Week .As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it.<br>Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects.<br>Last year, a group of us worked on extending my .<br>This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability.<br>And so we decided to port the classic  to Rust.id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality.<br>Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles.<br> by David Kushner tells the story; Fabien Sanglard’s  explains the technical details.Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general.<br>In addition, because its technology is more primitive, the source code is more approachable for study and implementation.<br>The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called .<br>All the drawing is done by directly putting pixels on the screen.A few years ago, after reading the Wolfenstein black book, I spent some time trying to , based on another modern port, .<br>I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project.<br>More recently, , who also read the book, proposed a Rust port as a project for this Hack Week.<br>Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before.<br>We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc.<br>This allowed us to make progress in parallel.The first task of porting the game is to read its data.<br>Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps.<br>One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods.<br>For Rustenstein, we used the .WL1 files of the shareware version, which we .Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C ) as well as a Page Manager to move assets from disk to RAM.<br>Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.Parsing and decompression code can be found  for maps, and  for the rest of the assets.Wolfenstein 3D maps are defined as 64x64 grids of tiles.<br>Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items.<br>The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc.<br>All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.Below is the first map of the first episode, as seen in a Wolfenstein map editor:And the same map as ASCII, as printed by our debugging code:For the graphic assets, decompressing and loading the data to memory is just half of the story.<br>The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for.<br>This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D.<br>The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in .<br>Since the  use a different set of abstractions (and, in particular, they don’t expose the  function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas.<br>This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork.<br>The first routine handles displaying a full image directly to the screen.<br>This is used for the title screen as well as the player status bar at the bottom of the in-game view:The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon.<br>A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.The related code can be found .At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm.<br>This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations.<br>The algorithm can be summarized as follows:Below is a simplified JavaScript version of the algorithm, based on :For a ray casting implementation closer to the original Wolfenstein 3D one,  is recommended.This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time.<br>First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures.<br>Second,  figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on  statements and had a lot of global side-effects in addition to calculating wall heights).Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:The full implementation can be found .The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color.<br>After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate.<br>While the algorithm was still in development, we tested the rendering code with hard-coded walls:Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:The , then, looks like this:A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project.<br>In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session.<br>We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before.<br>During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own.<br>And the project ended up winning the technical award of the event!The prototype is now , although, as said, the code still needs significant clean-up.<br>Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it.<br>Some of the features that we could tackle next are: Ready to be part of something incredible? See what’s possible when we roll together.<br>Interested in working with us? We are hiring!Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice.<br>It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company.<br>You can learn all about Hack Week .As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it.<br>Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects.<br>Last year, a group of us worked on extending my .<br>This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability.<br>And so we decided to port the classic  to Rust.id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality.<br>Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles.<br> by David Kushner tells the story; Fabien Sanglard’s  explains the technical details.Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general.<br>In addition, because its technology is more primitive, the source code is more approachable for study and implementation.<br>The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called .<br>All the drawing is done by directly putting pixels on the screen.A few years ago, after reading the Wolfenstein black book, I spent some time trying to , based on another modern port, .<br>I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project.<br>More recently, , who also read the book, proposed a Rust port as a project for this Hack Week.<br>Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before.<br>We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc.<br>This allowed us to make progress in parallel.The first task of porting the game is to read its data.<br>Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps.<br>One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods.<br>For Rustenstein, we used the .WL1 files of the shareware version, which we .Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C ) as well as a Page Manager to move assets from disk to RAM.<br>Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.Parsing and decompression code can be found  for maps, and  for the rest of the assets.Wolfenstein 3D maps are defined as 64x64 grids of tiles.<br>Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items.<br>The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc.<br>All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.Below is the first map of the first episode, as seen in a Wolfenstein map editor:And the same map as ASCII, as printed by our debugging code:For the graphic assets, decompressing and loading the data to memory is just half of the story.<br>The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for.<br>This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D.<br>The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in .<br>Since the  use a different set of abstractions (and, in particular, they don’t expose the  function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas.<br>This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork.<br>The first routine handles displaying a full image directly to the screen.<br>This is used for the title screen as well as the player status bar at the bottom of the in-game view:The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon.<br>A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.The related code can be found .At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm.<br>This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations.<br>The algorithm can be summarized as follows:Below is a simplified JavaScript version of the algorithm, based on :For a ray casting implementation closer to the original Wolfenstein 3D one,  is recommended.This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time.<br>First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures.<br>Second,  figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on  statements and had a lot of global side-effects in addition to calculating wall heights).Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:The full implementation can be found .The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color.<br>After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate.<br>While the algorithm was still in development, we tested the rendering code with hard-coded walls:Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:The , then, looks like this:A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project.<br>In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session.<br>We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before.<br>During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own.<br>And the project ended up winning the technical award of the event!The prototype is now , although, as said, the code still needs significant clean-up.<br>Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it.<br>Some of the features that we could tackle next are: Ready to be part of something incredible? See what’s possible when we roll together.<br>Interested in working with us? We are hiring!Twice a year, NextRoll celebrates Hack Week, where employees get to work for a week on a project of their choice.<br>It’s an excellent opportunity to experiment, learn new technologies and team up with people from across the company.<br>You can learn all about Hack Week .As NextRoll increasingly adopts the Rust programming language, it’s common for engineers to use Hack Week as an opportunity to gain experience with it.<br>Another popular choice is to work on video games and, as you may have guessed, we frequently see them combined in Rust video game projects.<br>Last year, a group of us worked on extending my .<br>This time, though, we wanted to step it up a notch with a project that would exercise some of Rust’s strengths: low-level programming, intense computations and C data interoperability.<br>And so we decided to port the classic  to Rust.id Software was famous for pushing the envelope of PC game programming: first by implementing NES-like side-scrollers on hardware that wasn’t prepared for it, then practically inventing and dominating the 3D first-person shooter genre, then making network and internet multiplayer a reality.<br>Along the way, they also popularized the shareware distribution method, encouraged community modding and open-sourced all of their hit titles.<br> by David Kushner tells the story; Fabien Sanglard’s  explains the technical details.Perhaps less notorious than its successors Doom and Quake, Wolfenstein 3D is a big milestone in id Software’s evolution and PC gaming in general.<br>In addition, because its technology is more primitive, the source code is more approachable for study and implementation.<br>The game doesn’t have a real 3D engine but rather simulates a 3D world from a 2D map using a technique called .<br>All the drawing is done by directly putting pixels on the screen.A few years ago, after reading the Wolfenstein black book, I spent some time trying to , based on another modern port, .<br>I tried to remain as close as possible to the original source, which proved to be very difficult, so I eventually dropped the project.<br>More recently, , who also read the book, proposed a Rust port as a project for this Hack Week.<br>Several people jumped in, and so did I; although, based on my previous experience, the enterprise still seemed daunting: some of us were new to Rust, some had never played Wolf, some hadn’t read the book yet, and none had implemented ray casting before.<br>We started without much hope of having something to show by the end of the week, but we saw enormous learning opportunities, so we dove right in.We roughly identified some components of the game that could be tackled separately, so each member picked one and went to work on it:In the cases where the output of one component was required as input for the next, we used pre-parsed or hard-coded data, extracted from the reference wolf4py and wolf4sdl implementations: decompressed binary dumps of assets, hardcoded maps and walls, etc.<br>This allowed us to make progress in parallel.The first task of porting the game is to read its data.<br>Wolfenstein ships with a set of files for its different assets: graphics (images, textures and sprites), audio (music and sound effects) and maps.<br>One of the complications is that each version of the game has slightly different files, with different offsets and, in some cases, using different compression methods.<br>For Rustenstein, we used the .WL1 files of the shareware version, which we .Each file uses a different combination of several decompression algorithms, all of which we had to port to Rust:The original Wolf engine has a Memory Manager component to handle memory allocation and compacting (instead of the traditional C ) as well as a Page Manager to move assets from disk to RAM.<br>Both components are unnecessary in modern hardware as we can safely assume that we can fit all assets in memory, so we did not include them in our port.Parsing and decompression code can be found  for maps, and  for the rest of the assets.Wolfenstein 3D maps are defined as 64x64 grids of tiles.<br>Each map has two layers of tiles: one for walls and doors, and another to place the player, enemies, and bonus items.<br>The different tile values determine what texture to render on walls, what locks are required for doors, what direction the player is facing, etc.<br>All walls have the same height and since they are represented as blocks in the tile grid, all intersections are rectangular; while this constrains the level designs, it dramatically simplifies the ray casting algorithm for drawing the 3D world.Below is the first map of the first episode, as seen in a Wolfenstein map editor:And the same map as ASCII, as printed by our debugging code:For the graphic assets, decompressing and loading the data to memory is just half of the story.<br>The binary chunks that make each graphic (image, sprite or texture) are arranged explicitly for fast rendering on the VGA displays the game was initially designed for.<br>This means that the graphics are rotated to be drawn in columns, and the columns themselves appear interleaved in the file since VGA allowed for parallel writing to four different video memory banks.Each byte in the graphic binary chunks is an index to the 256 color palette used in Wolfenstein 3D.<br>The reference wolf4sdl implementation would write those chunks to an SDL surface, which would, in turn, be translated to RGB colors before being copied to the screen, as described in .<br>Since the  use a different set of abstractions (and, in particular, they don’t expose the  function), we opted for converting from palette index to RGB colors on the fly, writing directly to an RGB texture that then gets copied to the renderable canvas.<br>This means that the rendering routines need to be adapted to write red, green and blue bytes to form each pixel, instead of the single palette index byte.The two graphic rendering routines we implemented were directly ported from the wolf4py implementation, which in turn was ported almost line by line from the wolf4sdl reference fork.<br>The first routine handles displaying a full image directly to the screen.<br>This is used for the title screen as well as the player status bar at the bottom of the in-game view:The second routine, a much more complex one, is in charge of drawing sprites and is currently used to display the player weapon.<br>A similar but even more complicated function is left to be ported: the one that draws scaled images such as wall textures and enemy sprites.It would be desirable to improve this implementation such that most of the processing is done once as part of the asset loading step, and the binary chunks are kept in memory, ready to be written to the screen.The related code can be found .At the heart of the Wolfenstein 3D engine is the Ray Casting algorithm.<br>This routine allows us to project a 2D world (defined by the 64x64 tilemap) into a 3D view, solely based on 2D operations.<br>The algorithm can be summarized as follows:Below is a simplified JavaScript version of the algorithm, based on :For a ray casting implementation closer to the original Wolfenstein 3D one,  is recommended.This routine was clearly the most challenging we tackled during this Hack Week, but we made a couple of decisions early on that reduced the complexity enough to be able to deliver something on time.<br>First, we went with the most basic version of the algorithm that supports walls of solid colors instead of textures.<br>Second,  figured out ray casting separately, based on tutorials, instead of trying to make a line-by-line port of the original Carmack implementation (which, quoting Sanglard, is a “fully-handcrafted 740 lines of highly unorthodox and super efficient assembly code”) or its wolf4sdl counterpart (which is C but still relied heavily on  statements and had a lot of global side-effects in addition to calculating wall heights).Here’s what the top-down view of the first Wolf map looked like after integrating it into the ray casting routine:The full implementation can be found .The 3D world is displayed by first splitting the screen horizontally in two halves, painting the upper half with a ceiling solid color and the lower half with a floor color.<br>After that, a pixel column needs to be drawn with the height received from the ray casting algorithm for each horizontal coordinate.<br>While the algorithm was still in development, we tested the rendering code with hard-coded walls:Once the ray casting routine was implemented and fed with an actual Wolfenstein map, we got an array of wall heights for each pixel column in the screen, and we started to see the world:Although we haven’t implemented texture rendering, there are a couple of tricks that improve the appearance of the scene: using different colors for the horizontal and vertical faces of a wall, and making the r, g, b components of each pixel inversely proportional to the distance to the player (which we know from the height of the wall), to generate a darkness effect:The , then, looks like this:A day before the demo, we only had pieces of the game: asset loading wasn’t finished, we had show-stopper bugs in map parsing and sprite rendering, and the ray casting engine was working in a 2D hardcoded map, separate from the rest of the project.<br>In an amazing few final hours, everything just fell into place: the bugs were ironed out, the different components fit together and, with a few hacks and a lot of ugly code, we managed to put together an impressive-looking video, just in time for the Hack Week demo session.<br>We even had time to throw in a last-minute face animation of the character! The whole experience reminded me of those stories about video game companies putting together one-off builds in a hurry, just to make it to E3 demos.This is still far from a functioning game, but it surpassed our most optimistic predictions from a few days before.<br>During this week, we learned a fair deal about Rust, and we went further than we could have if we were working on our own.<br>And the project ended up winning the technical award of the event!The prototype is now , although, as said, the code still needs significant clean-up.<br>Since the project was a lot of fun and, in this first week, we managed to solve some of the most challenging parts (assets loading, ray casting, sprite and wall rendering), we’re eager to continue working on it.<br>Some of the features that we could tackle next are: Ready to be part of something incredible? See what’s possible when we roll together.<br></p>
